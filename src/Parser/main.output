Terminals unused in grammar

   RETURN
   STRING
   LOG_AND
   LOG_OR


Rules useless in parser due to conflicts

    7 ED: if
   16   | %empty

   61 else_if: else_if


State 0 conflicts: 1 reduce/reduce
State 22 conflicts: 1 reduce/reduce
State 24 conflicts: 1 reduce/reduce
State 51 conflicts: 1 shift/reduce
State 57 conflicts: 1 shift/reduce
State 58 conflicts: 1 shift/reduce
State 63 conflicts: 1 shift/reduce


Grammar

    0 $accept: ED $end

    1 ED: expr
    2   | block
    3   | if
    4   | datatype
    5   | var_dec
    6   | var_def
    7   | if
    8   | else
    9   | if_else
   10   | if_else_if
   11   | while
   12   | func_dec
   13   | func_def
   14   | else_if
   15   | %empty
   16   | %empty

   17 expr: expr AR_PLUS expr
   18     | expr AR_MINUS expr
   19     | expr AR_MUL expr
   20     | expr AR_DIV expr
   21     | expr AR_MOD expr
   22     | expr AR_PLUS AR_PLUS
   23     | expr BITWISE_XOR expr
   24     | expr BITWISE_OR expr
   25     | expr BITWISE_AND expr
   26     | expr BITWISE_AND BITWISE_AND expr
   27     | expr BITWISE_OR BITWISE_AND expr
   28     | expr LOG_COMPARE LOG_COMPARE expr
   29     | expr REL_LESSTHAN expr
   30     | expr REL_LESSEQUAL expr
   31     | expr REL_EQUAL expr
   32     | expr REL_GREATEQUAL expr
   33     | expr REL_GREATERTHAN expr
   34     | expr REL_NOTEQUAL expr
   35     | NUM_INTEGER
   36     | NUM_FLOAT
   37     | IDENTIFIER
   38     | %empty

   39 datatype: FLOAT
   40         | DOUBLE
   41         | CHAR
   42         | UNSIGNED CHAR
   43         | INT
   44         | UNSIGNED INT
   45         | SHORT INT
   46         | SHORT UNSIGNED INT
   47         | LONG INT
   48         | LONG UNSIGNED INT
   49         | "void"

   50 var_dec: datatype IDENTIFIER

   51 var_def: var_dec '=' NUM_FLOAT
   52        | var_dec '=' NUM_INTEGER
   53        | IDENTIFIER '=' NUM_FLOAT
   54        | IDENTIFIER '=' NUM_INTEGER

   55 block: L_FLOWER_BRKT R_FLOWER_BRKT
   56      | L_FLOWER_BRKT block R_FLOWER_BRKT
   57      | L_FLOWER_BRKT "blah!" R_FLOWER_BRKT

   58 if: IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

   59 else: ELSE L_FLOWER_BRKT block R_FLOWER_BRKT

   60 else_if: ELSE IF L_FLOWER_BRKT expr R_FLOWER_BRKT L_FLOWER_BRKT block R_FLOWER_BRKT
   61        | else_if

   62 if_else: if else

   63 if_else_if: if else_if else

   64 while: WHILE L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

   65 arg: datatype IDENTIFIER
   66    | arg ','

   67 func_dec: datatype IDENTIFIER L_PAREN arg R_PAREN

   68 func_def: func_dec block


Terminals, with rules where they appear

$end (0) 0
',' (44) 66
'=' (61) 51 52 53 54
error (256)
CHAR (258) 41 42
INT (259) 43 44 45 46 47 48
FLOAT (260) 39
DOUBLE (261) 40
SHORT (262) 45 46
UNSIGNED (263) 42 44 46 48
LONG (264) 47 48
RETURN (265)
IF (266) 58 60
ELSE (267) 59 60
WHILE (268) 64
L_FLOWER_BRKT (269) 55 56 57 58 59 60 64
R_FLOWER_BRKT (270) 55 56 57 58 59 60 64
L_PAREN (271) 58 64 67
R_PAREN (272) 58 64 67
STRING (273)
IDENTIFIER (274) 37 50 53 54 65 67
NUM_INTEGER (275) 35 52 54
NUM_FLOAT (276) 36 51 53
REL_LESSEQUAL (277) 30
REL_GREATEQUAL (278) 32
REL_EQUAL (279) 31
REL_NOTEQUAL (280) 34
REL_LESSTHAN (281) 29
REL_GREATERTHAN (282) 33
AR_PLUS (283) 17 22
AR_MINUS (284) 18
AR_MUL (285) 19
AR_DIV (286) 20
AR_MOD (287) 21
BITWISE_XOR (288) 23
BITWISE_AND (289) 25 26 27
BITWISE_OR (290) 24 27
LOG_AND (291)
LOG_OR (292)
LOG_COMPARE (293) 28
"void" (294) 49
"blah!" (295) 57


Nonterminals, with rules where they appear

$accept (43)
    on left: 0
ED (44)
    on left: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16, on right: 0
expr (45)
    on left: 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34
    35 36 37 38, on right: 1 17 18 19 20 21 22 23 24 25 26 27 28 29
    30 31 32 33 34 58 60 64
datatype (46)
    on left: 39 40 41 42 43 44 45 46 47 48 49, on right: 4 50 65 67
var_dec (47)
    on left: 50, on right: 5 51 52
var_def (48)
    on left: 51 52 53 54, on right: 6
block (49)
    on left: 55 56 57, on right: 2 56 58 59 60 64 68
if (50)
    on left: 58, on right: 3 7 62 63
else (51)
    on left: 59, on right: 8 62 63
else_if (52)
    on left: 60 61, on right: 14 61 63
if_else (53)
    on left: 62, on right: 9
if_else_if (54)
    on left: 63, on right: 10
while (55)
    on left: 64, on right: 11
arg (56)
    on left: 65 66, on right: 66 67
func_dec (57)
    on left: 67, on right: 12 68
func_def (58)
    on left: 68, on right: 13


State 0

    0 $accept: . ED $end
    1 ED: . expr
    2   | . block
    3   | . if
    4   | . datatype
    5   | . var_dec
    6   | . var_def
    7   | . if
    8   | . else
    9   | . if_else
   10   | . if_else_if
   11   | . while
   12   | . func_dec
   13   | . func_def
   14   | . else_if
   15   | . %empty  [$end]
   16   | . %empty  [$end]
   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [$end, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]
   39 datatype: . FLOAT
   40         | . DOUBLE
   41         | . CHAR
   42         | . UNSIGNED CHAR
   43         | . INT
   44         | . UNSIGNED INT
   45         | . SHORT INT
   46         | . SHORT UNSIGNED INT
   47         | . LONG INT
   48         | . LONG UNSIGNED INT
   49         | . "void"
   50 var_dec: . datatype IDENTIFIER
   51 var_def: . var_dec '=' NUM_FLOAT
   52        | . var_dec '=' NUM_INTEGER
   53        | . IDENTIFIER '=' NUM_FLOAT
   54        | . IDENTIFIER '=' NUM_INTEGER
   55 block: . L_FLOWER_BRKT R_FLOWER_BRKT
   56      | . L_FLOWER_BRKT block R_FLOWER_BRKT
   57      | . L_FLOWER_BRKT "blah!" R_FLOWER_BRKT
   58 if: . IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT
   59 else: . ELSE L_FLOWER_BRKT block R_FLOWER_BRKT
   60 else_if: . ELSE IF L_FLOWER_BRKT expr R_FLOWER_BRKT L_FLOWER_BRKT block R_FLOWER_BRKT
   61        | . else_if
   62 if_else: . if else
   63 if_else_if: . if else_if else
   64 while: . WHILE L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT
   67 func_dec: . datatype IDENTIFIER L_PAREN arg R_PAREN
   68 func_def: . func_dec block

    CHAR           shift, and go to state 1
    INT            shift, and go to state 2
    FLOAT          shift, and go to state 3
    DOUBLE         shift, and go to state 4
    SHORT          shift, and go to state 5
    UNSIGNED       shift, and go to state 6
    LONG           shift, and go to state 7
    IF             shift, and go to state 8
    ELSE           shift, and go to state 9
    WHILE          shift, and go to state 10
    L_FLOWER_BRKT  shift, and go to state 11
    IDENTIFIER     shift, and go to state 12
    NUM_INTEGER    shift, and go to state 13
    NUM_FLOAT      shift, and go to state 14
    "void"         shift, and go to state 15

    $end      reduce using rule 15 (ED)
    $end      [reduce using rule 16 (ED)]
    $end      [reduce using rule 38 (expr)]
    $default  reduce using rule 38 (expr)

    ED          go to state 16
    expr        go to state 17
    datatype    go to state 18
    var_dec     go to state 19
    var_def     go to state 20
    block       go to state 21
    if          go to state 22
    else        go to state 23
    else_if     go to state 24
    if_else     go to state 25
    if_else_if  go to state 26
    while       go to state 27
    func_dec    go to state 28
    func_def    go to state 29


State 1

   41 datatype: CHAR .

    $default  reduce using rule 41 (datatype)


State 2

   43 datatype: INT .

    $default  reduce using rule 43 (datatype)


State 3

   39 datatype: FLOAT .

    $default  reduce using rule 39 (datatype)


State 4

   40 datatype: DOUBLE .

    $default  reduce using rule 40 (datatype)


State 5

   45 datatype: SHORT . INT
   46         | SHORT . UNSIGNED INT

    INT       shift, and go to state 30
    UNSIGNED  shift, and go to state 31


State 6

   42 datatype: UNSIGNED . CHAR
   44         | UNSIGNED . INT

    CHAR  shift, and go to state 32
    INT   shift, and go to state 33


State 7

   47 datatype: LONG . INT
   48         | LONG . UNSIGNED INT

    INT       shift, and go to state 34
    UNSIGNED  shift, and go to state 35


State 8

   58 if: IF . L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

    L_PAREN  shift, and go to state 36


State 9

   59 else: ELSE . L_FLOWER_BRKT block R_FLOWER_BRKT
   60 else_if: ELSE . IF L_FLOWER_BRKT expr R_FLOWER_BRKT L_FLOWER_BRKT block R_FLOWER_BRKT

    IF             shift, and go to state 37
    L_FLOWER_BRKT  shift, and go to state 38


State 10

   64 while: WHILE . L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

    L_PAREN  shift, and go to state 39


State 11

   55 block: . L_FLOWER_BRKT R_FLOWER_BRKT
   55      | L_FLOWER_BRKT . R_FLOWER_BRKT
   56      | . L_FLOWER_BRKT block R_FLOWER_BRKT
   56      | L_FLOWER_BRKT . block R_FLOWER_BRKT
   57      | . L_FLOWER_BRKT "blah!" R_FLOWER_BRKT
   57      | L_FLOWER_BRKT . "blah!" R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 11
    R_FLOWER_BRKT  shift, and go to state 40
    "blah!"        shift, and go to state 41

    block  go to state 42


State 12

   37 expr: IDENTIFIER .  [$end, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]
   53 var_def: IDENTIFIER . '=' NUM_FLOAT
   54        | IDENTIFIER . '=' NUM_INTEGER

    '='  shift, and go to state 43

    $default  reduce using rule 37 (expr)


State 13

   35 expr: NUM_INTEGER .

    $default  reduce using rule 35 (expr)


State 14

   36 expr: NUM_FLOAT .

    $default  reduce using rule 36 (expr)


State 15

   49 datatype: "void" .

    $default  reduce using rule 49 (datatype)


State 16

    0 $accept: ED . $end

    $end  shift, and go to state 44


State 17

    1 ED: expr .  [$end]
   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr

    REL_LESSEQUAL    shift, and go to state 45
    REL_GREATEQUAL   shift, and go to state 46
    REL_EQUAL        shift, and go to state 47
    REL_NOTEQUAL     shift, and go to state 48
    REL_LESSTHAN     shift, and go to state 49
    REL_GREATERTHAN  shift, and go to state 50
    AR_PLUS          shift, and go to state 51
    AR_MINUS         shift, and go to state 52
    AR_MUL           shift, and go to state 53
    AR_DIV           shift, and go to state 54
    AR_MOD           shift, and go to state 55
    BITWISE_XOR      shift, and go to state 56
    BITWISE_AND      shift, and go to state 57
    BITWISE_OR       shift, and go to state 58
    LOG_COMPARE      shift, and go to state 59

    $default  reduce using rule 1 (ED)


State 18

    4 ED: datatype .  [$end]
   50 var_dec: datatype . IDENTIFIER
   67 func_dec: datatype . IDENTIFIER L_PAREN arg R_PAREN

    IDENTIFIER  shift, and go to state 60

    $default  reduce using rule 4 (ED)


State 19

    5 ED: var_dec .  [$end]
   51 var_def: var_dec . '=' NUM_FLOAT
   52        | var_dec . '=' NUM_INTEGER

    '='  shift, and go to state 61

    $default  reduce using rule 5 (ED)


State 20

    6 ED: var_def .

    $default  reduce using rule 6 (ED)


State 21

    2 ED: block .

    $default  reduce using rule 2 (ED)


State 22

    3 ED: if .  [$end]
    7   | if .  [$end]
   59 else: . ELSE L_FLOWER_BRKT block R_FLOWER_BRKT
   60 else_if: . ELSE IF L_FLOWER_BRKT expr R_FLOWER_BRKT L_FLOWER_BRKT block R_FLOWER_BRKT
   61        | . else_if
   62 if_else: if . else
   63 if_else_if: if . else_if else

    ELSE  shift, and go to state 9

    $end      reduce using rule 3 (ED)
    $end      [reduce using rule 7 (ED)]
    $default  reduce using rule 3 (ED)

    else     go to state 62
    else_if  go to state 63


State 23

    8 ED: else .

    $default  reduce using rule 8 (ED)


State 24

   14 ED: else_if .  [$end]
   61 else_if: else_if .  [$end]

    $end      reduce using rule 14 (ED)
    $end      [reduce using rule 61 (else_if)]
    $default  reduce using rule 14 (ED)


State 25

    9 ED: if_else .

    $default  reduce using rule 9 (ED)


State 26

   10 ED: if_else_if .

    $default  reduce using rule 10 (ED)


State 27

   11 ED: while .

    $default  reduce using rule 11 (ED)


State 28

   12 ED: func_dec .  [$end]
   55 block: . L_FLOWER_BRKT R_FLOWER_BRKT
   56      | . L_FLOWER_BRKT block R_FLOWER_BRKT
   57      | . L_FLOWER_BRKT "blah!" R_FLOWER_BRKT
   68 func_def: func_dec . block

    L_FLOWER_BRKT  shift, and go to state 11

    $default  reduce using rule 12 (ED)

    block  go to state 64


State 29

   13 ED: func_def .

    $default  reduce using rule 13 (ED)


State 30

   45 datatype: SHORT INT .

    $default  reduce using rule 45 (datatype)


State 31

   46 datatype: SHORT UNSIGNED . INT

    INT  shift, and go to state 65


State 32

   42 datatype: UNSIGNED CHAR .

    $default  reduce using rule 42 (datatype)


State 33

   44 datatype: UNSIGNED INT .

    $default  reduce using rule 44 (datatype)


State 34

   47 datatype: LONG INT .

    $default  reduce using rule 47 (datatype)


State 35

   48 datatype: LONG UNSIGNED . INT

    INT  shift, and go to state 66


State 36

   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]
   58 if: IF L_PAREN . expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14

    $default  reduce using rule 38 (expr)

    expr  go to state 68


State 37

   60 else_if: ELSE IF . L_FLOWER_BRKT expr R_FLOWER_BRKT L_FLOWER_BRKT block R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 69


State 38

   55 block: . L_FLOWER_BRKT R_FLOWER_BRKT
   56      | . L_FLOWER_BRKT block R_FLOWER_BRKT
   57      | . L_FLOWER_BRKT "blah!" R_FLOWER_BRKT
   59 else: ELSE L_FLOWER_BRKT . block R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 11

    block  go to state 70


State 39

   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]
   64 while: WHILE L_PAREN . expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14

    $default  reduce using rule 38 (expr)

    expr  go to state 71


State 40

   55 block: L_FLOWER_BRKT R_FLOWER_BRKT .

    $default  reduce using rule 55 (block)


State 41

   57 block: L_FLOWER_BRKT "blah!" . R_FLOWER_BRKT

    R_FLOWER_BRKT  shift, and go to state 72


State 42

   56 block: L_FLOWER_BRKT block . R_FLOWER_BRKT

    R_FLOWER_BRKT  shift, and go to state 73


State 43

   53 var_def: IDENTIFIER '=' . NUM_FLOAT
   54        | IDENTIFIER '=' . NUM_INTEGER

    NUM_INTEGER  shift, and go to state 74
    NUM_FLOAT    shift, and go to state 75


State 44

    0 $accept: ED $end .

    $default  accept


State 45

   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   30     | expr REL_LESSEQUAL . expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14

    $default  reduce using rule 38 (expr)

    expr  go to state 76


State 46

   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   32     | expr REL_GREATEQUAL . expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14

    $default  reduce using rule 38 (expr)

    expr  go to state 77


State 47

   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   31     | expr REL_EQUAL . expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14

    $default  reduce using rule 38 (expr)

    expr  go to state 78


State 48

   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   34     | expr REL_NOTEQUAL . expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14

    $default  reduce using rule 38 (expr)

    expr  go to state 79


State 49

   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   29     | expr REL_LESSTHAN . expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14

    $default  reduce using rule 38 (expr)

    expr  go to state 80


State 50

   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   33     | expr REL_GREATERTHAN . expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14

    $default  reduce using rule 38 (expr)

    expr  go to state 81


State 51

   17 expr: . expr AR_PLUS expr
   17     | expr AR_PLUS . expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   22     | expr AR_PLUS . AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14
    AR_PLUS      shift, and go to state 82

    AR_PLUS   [reduce using rule 38 (expr)]
    $default  reduce using rule 38 (expr)

    expr  go to state 83


State 52

   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   18     | expr AR_MINUS . expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14

    $default  reduce using rule 38 (expr)

    expr  go to state 84


State 53

   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   19     | expr AR_MUL . expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14

    $default  reduce using rule 38 (expr)

    expr  go to state 85


State 54

   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   20     | expr AR_DIV . expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14

    $default  reduce using rule 38 (expr)

    expr  go to state 86


State 55

   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   21     | expr AR_MOD . expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14

    $default  reduce using rule 38 (expr)

    expr  go to state 87


State 56

   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   23     | expr BITWISE_XOR . expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14

    $default  reduce using rule 38 (expr)

    expr  go to state 88


State 57

   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   25     | expr BITWISE_AND . expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   26     | expr BITWISE_AND . BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14
    BITWISE_AND  shift, and go to state 89

    BITWISE_AND  [reduce using rule 38 (expr)]
    $default     reduce using rule 38 (expr)

    expr  go to state 90


State 58

   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   24     | expr BITWISE_OR . expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   27     | expr BITWISE_OR . BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14
    BITWISE_AND  shift, and go to state 91

    BITWISE_AND  [reduce using rule 38 (expr)]
    $default     reduce using rule 38 (expr)

    expr  go to state 92


State 59

   28 expr: expr LOG_COMPARE . LOG_COMPARE expr

    LOG_COMPARE  shift, and go to state 93


State 60

   50 var_dec: datatype IDENTIFIER .  [$end, '=']
   67 func_dec: datatype IDENTIFIER . L_PAREN arg R_PAREN

    L_PAREN  shift, and go to state 94

    $default  reduce using rule 50 (var_dec)


State 61

   51 var_def: var_dec '=' . NUM_FLOAT
   52        | var_dec '=' . NUM_INTEGER

    NUM_INTEGER  shift, and go to state 95
    NUM_FLOAT    shift, and go to state 96


State 62

   62 if_else: if else .

    $default  reduce using rule 62 (if_else)


State 63

   59 else: . ELSE L_FLOWER_BRKT block R_FLOWER_BRKT
   61 else_if: else_if .  [ELSE]
   63 if_else_if: if else_if . else

    ELSE  shift, and go to state 97

    ELSE  [reduce using rule 61 (else_if)]

    else  go to state 98


State 64

   68 func_def: func_dec block .

    $default  reduce using rule 68 (func_def)


State 65

   46 datatype: SHORT UNSIGNED INT .

    $default  reduce using rule 46 (datatype)


State 66

   48 datatype: LONG UNSIGNED INT .

    $default  reduce using rule 48 (datatype)


State 67

   37 expr: IDENTIFIER .

    $default  reduce using rule 37 (expr)


State 68

   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr
   58 if: IF L_PAREN expr . R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

    R_PAREN          shift, and go to state 99
    REL_LESSEQUAL    shift, and go to state 45
    REL_GREATEQUAL   shift, and go to state 46
    REL_EQUAL        shift, and go to state 47
    REL_NOTEQUAL     shift, and go to state 48
    REL_LESSTHAN     shift, and go to state 49
    REL_GREATERTHAN  shift, and go to state 50
    AR_PLUS          shift, and go to state 51
    AR_MINUS         shift, and go to state 52
    AR_MUL           shift, and go to state 53
    AR_DIV           shift, and go to state 54
    AR_MOD           shift, and go to state 55
    BITWISE_XOR      shift, and go to state 56
    BITWISE_AND      shift, and go to state 57
    BITWISE_OR       shift, and go to state 58
    LOG_COMPARE      shift, and go to state 59


State 69

   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [R_FLOWER_BRKT, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]
   60 else_if: ELSE IF L_FLOWER_BRKT . expr R_FLOWER_BRKT L_FLOWER_BRKT block R_FLOWER_BRKT

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14

    $default  reduce using rule 38 (expr)

    expr  go to state 100


State 70

   59 else: ELSE L_FLOWER_BRKT block . R_FLOWER_BRKT

    R_FLOWER_BRKT  shift, and go to state 101


State 71

   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr
   64 while: WHILE L_PAREN expr . R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

    R_PAREN          shift, and go to state 102
    REL_LESSEQUAL    shift, and go to state 45
    REL_GREATEQUAL   shift, and go to state 46
    REL_EQUAL        shift, and go to state 47
    REL_NOTEQUAL     shift, and go to state 48
    REL_LESSTHAN     shift, and go to state 49
    REL_GREATERTHAN  shift, and go to state 50
    AR_PLUS          shift, and go to state 51
    AR_MINUS         shift, and go to state 52
    AR_MUL           shift, and go to state 53
    AR_DIV           shift, and go to state 54
    AR_MOD           shift, and go to state 55
    BITWISE_XOR      shift, and go to state 56
    BITWISE_AND      shift, and go to state 57
    BITWISE_OR       shift, and go to state 58
    LOG_COMPARE      shift, and go to state 59


State 72

   57 block: L_FLOWER_BRKT "blah!" R_FLOWER_BRKT .

    $default  reduce using rule 57 (block)


State 73

   56 block: L_FLOWER_BRKT block R_FLOWER_BRKT .

    $default  reduce using rule 56 (block)


State 74

   54 var_def: IDENTIFIER '=' NUM_INTEGER .

    $default  reduce using rule 54 (var_def)


State 75

   53 var_def: IDENTIFIER '=' NUM_FLOAT .

    $default  reduce using rule 53 (var_def)


State 76

   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   30     | expr REL_LESSEQUAL expr .  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN]
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr

    AR_PLUS      shift, and go to state 51
    AR_MINUS     shift, and go to state 52
    AR_MUL       shift, and go to state 53
    AR_DIV       shift, and go to state 54
    AR_MOD       shift, and go to state 55
    BITWISE_XOR  shift, and go to state 56
    BITWISE_AND  shift, and go to state 57
    BITWISE_OR   shift, and go to state 58
    LOG_COMPARE  shift, and go to state 59

    $default  reduce using rule 30 (expr)

    Conflict between rule 30 and token REL_LESSEQUAL resolved as reduce (%left REL_LESSEQUAL).
    Conflict between rule 30 and token REL_GREATEQUAL resolved as reduce (%left REL_GREATEQUAL).
    Conflict between rule 30 and token REL_EQUAL resolved as reduce (%left REL_EQUAL).
    Conflict between rule 30 and token REL_NOTEQUAL resolved as reduce (%left REL_NOTEQUAL).
    Conflict between rule 30 and token REL_LESSTHAN resolved as reduce (%left REL_LESSTHAN).
    Conflict between rule 30 and token REL_GREATERTHAN resolved as reduce (%left REL_GREATERTHAN).
    Conflict between rule 30 and token AR_PLUS resolved as shift (REL_LESSEQUAL < AR_PLUS).
    Conflict between rule 30 and token AR_MINUS resolved as shift (REL_LESSEQUAL < AR_MINUS).
    Conflict between rule 30 and token AR_MUL resolved as shift (REL_LESSEQUAL < AR_MUL).
    Conflict between rule 30 and token AR_DIV resolved as shift (REL_LESSEQUAL < AR_DIV).
    Conflict between rule 30 and token AR_MOD resolved as shift (REL_LESSEQUAL < AR_MOD).
    Conflict between rule 30 and token BITWISE_XOR resolved as shift (REL_LESSEQUAL < BITWISE_XOR).
    Conflict between rule 30 and token BITWISE_AND resolved as shift (REL_LESSEQUAL < BITWISE_AND).
    Conflict between rule 30 and token BITWISE_OR resolved as shift (REL_LESSEQUAL < BITWISE_OR).
    Conflict between rule 30 and token LOG_COMPARE resolved as shift (REL_LESSEQUAL < LOG_COMPARE).


State 77

   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   32     | expr REL_GREATEQUAL expr .  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN]
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr

    AR_PLUS      shift, and go to state 51
    AR_MINUS     shift, and go to state 52
    AR_MUL       shift, and go to state 53
    AR_DIV       shift, and go to state 54
    AR_MOD       shift, and go to state 55
    BITWISE_XOR  shift, and go to state 56
    BITWISE_AND  shift, and go to state 57
    BITWISE_OR   shift, and go to state 58
    LOG_COMPARE  shift, and go to state 59

    $default  reduce using rule 32 (expr)

    Conflict between rule 32 and token REL_LESSEQUAL resolved as reduce (%left REL_LESSEQUAL).
    Conflict between rule 32 and token REL_GREATEQUAL resolved as reduce (%left REL_GREATEQUAL).
    Conflict between rule 32 and token REL_EQUAL resolved as reduce (%left REL_EQUAL).
    Conflict between rule 32 and token REL_NOTEQUAL resolved as reduce (%left REL_NOTEQUAL).
    Conflict between rule 32 and token REL_LESSTHAN resolved as reduce (%left REL_LESSTHAN).
    Conflict between rule 32 and token REL_GREATERTHAN resolved as reduce (%left REL_GREATERTHAN).
    Conflict between rule 32 and token AR_PLUS resolved as shift (REL_GREATEQUAL < AR_PLUS).
    Conflict between rule 32 and token AR_MINUS resolved as shift (REL_GREATEQUAL < AR_MINUS).
    Conflict between rule 32 and token AR_MUL resolved as shift (REL_GREATEQUAL < AR_MUL).
    Conflict between rule 32 and token AR_DIV resolved as shift (REL_GREATEQUAL < AR_DIV).
    Conflict between rule 32 and token AR_MOD resolved as shift (REL_GREATEQUAL < AR_MOD).
    Conflict between rule 32 and token BITWISE_XOR resolved as shift (REL_GREATEQUAL < BITWISE_XOR).
    Conflict between rule 32 and token BITWISE_AND resolved as shift (REL_GREATEQUAL < BITWISE_AND).
    Conflict between rule 32 and token BITWISE_OR resolved as shift (REL_GREATEQUAL < BITWISE_OR).
    Conflict between rule 32 and token LOG_COMPARE resolved as shift (REL_GREATEQUAL < LOG_COMPARE).


State 78

   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   31     | expr REL_EQUAL expr .  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN]
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr

    AR_PLUS      shift, and go to state 51
    AR_MINUS     shift, and go to state 52
    AR_MUL       shift, and go to state 53
    AR_DIV       shift, and go to state 54
    AR_MOD       shift, and go to state 55
    BITWISE_XOR  shift, and go to state 56
    BITWISE_AND  shift, and go to state 57
    BITWISE_OR   shift, and go to state 58
    LOG_COMPARE  shift, and go to state 59

    $default  reduce using rule 31 (expr)

    Conflict between rule 31 and token REL_LESSEQUAL resolved as reduce (%left REL_LESSEQUAL).
    Conflict between rule 31 and token REL_GREATEQUAL resolved as reduce (%left REL_GREATEQUAL).
    Conflict between rule 31 and token REL_EQUAL resolved as reduce (%left REL_EQUAL).
    Conflict between rule 31 and token REL_NOTEQUAL resolved as reduce (%left REL_NOTEQUAL).
    Conflict between rule 31 and token REL_LESSTHAN resolved as reduce (%left REL_LESSTHAN).
    Conflict between rule 31 and token REL_GREATERTHAN resolved as reduce (%left REL_GREATERTHAN).
    Conflict between rule 31 and token AR_PLUS resolved as shift (REL_EQUAL < AR_PLUS).
    Conflict between rule 31 and token AR_MINUS resolved as shift (REL_EQUAL < AR_MINUS).
    Conflict between rule 31 and token AR_MUL resolved as shift (REL_EQUAL < AR_MUL).
    Conflict between rule 31 and token AR_DIV resolved as shift (REL_EQUAL < AR_DIV).
    Conflict between rule 31 and token AR_MOD resolved as shift (REL_EQUAL < AR_MOD).
    Conflict between rule 31 and token BITWISE_XOR resolved as shift (REL_EQUAL < BITWISE_XOR).
    Conflict between rule 31 and token BITWISE_AND resolved as shift (REL_EQUAL < BITWISE_AND).
    Conflict between rule 31 and token BITWISE_OR resolved as shift (REL_EQUAL < BITWISE_OR).
    Conflict between rule 31 and token LOG_COMPARE resolved as shift (REL_EQUAL < LOG_COMPARE).


State 79

   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr
   34     | expr REL_NOTEQUAL expr .  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN]

    AR_PLUS      shift, and go to state 51
    AR_MINUS     shift, and go to state 52
    AR_MUL       shift, and go to state 53
    AR_DIV       shift, and go to state 54
    AR_MOD       shift, and go to state 55
    BITWISE_XOR  shift, and go to state 56
    BITWISE_AND  shift, and go to state 57
    BITWISE_OR   shift, and go to state 58
    LOG_COMPARE  shift, and go to state 59

    $default  reduce using rule 34 (expr)

    Conflict between rule 34 and token REL_LESSEQUAL resolved as reduce (%left REL_LESSEQUAL).
    Conflict between rule 34 and token REL_GREATEQUAL resolved as reduce (%left REL_GREATEQUAL).
    Conflict between rule 34 and token REL_EQUAL resolved as reduce (%left REL_EQUAL).
    Conflict between rule 34 and token REL_NOTEQUAL resolved as reduce (%left REL_NOTEQUAL).
    Conflict between rule 34 and token REL_LESSTHAN resolved as reduce (%left REL_LESSTHAN).
    Conflict between rule 34 and token REL_GREATERTHAN resolved as reduce (%left REL_GREATERTHAN).
    Conflict between rule 34 and token AR_PLUS resolved as shift (REL_NOTEQUAL < AR_PLUS).
    Conflict between rule 34 and token AR_MINUS resolved as shift (REL_NOTEQUAL < AR_MINUS).
    Conflict between rule 34 and token AR_MUL resolved as shift (REL_NOTEQUAL < AR_MUL).
    Conflict between rule 34 and token AR_DIV resolved as shift (REL_NOTEQUAL < AR_DIV).
    Conflict between rule 34 and token AR_MOD resolved as shift (REL_NOTEQUAL < AR_MOD).
    Conflict between rule 34 and token BITWISE_XOR resolved as shift (REL_NOTEQUAL < BITWISE_XOR).
    Conflict between rule 34 and token BITWISE_AND resolved as shift (REL_NOTEQUAL < BITWISE_AND).
    Conflict between rule 34 and token BITWISE_OR resolved as shift (REL_NOTEQUAL < BITWISE_OR).
    Conflict between rule 34 and token LOG_COMPARE resolved as shift (REL_NOTEQUAL < LOG_COMPARE).


State 80

   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   29     | expr REL_LESSTHAN expr .  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN]
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr

    AR_PLUS      shift, and go to state 51
    AR_MINUS     shift, and go to state 52
    AR_MUL       shift, and go to state 53
    AR_DIV       shift, and go to state 54
    AR_MOD       shift, and go to state 55
    BITWISE_XOR  shift, and go to state 56
    BITWISE_AND  shift, and go to state 57
    BITWISE_OR   shift, and go to state 58
    LOG_COMPARE  shift, and go to state 59

    $default  reduce using rule 29 (expr)

    Conflict between rule 29 and token REL_LESSEQUAL resolved as reduce (%left REL_LESSEQUAL).
    Conflict between rule 29 and token REL_GREATEQUAL resolved as reduce (%left REL_GREATEQUAL).
    Conflict between rule 29 and token REL_EQUAL resolved as reduce (%left REL_EQUAL).
    Conflict between rule 29 and token REL_NOTEQUAL resolved as reduce (%left REL_NOTEQUAL).
    Conflict between rule 29 and token REL_LESSTHAN resolved as reduce (%left REL_LESSTHAN).
    Conflict between rule 29 and token REL_GREATERTHAN resolved as reduce (%left REL_GREATERTHAN).
    Conflict between rule 29 and token AR_PLUS resolved as shift (REL_LESSTHAN < AR_PLUS).
    Conflict between rule 29 and token AR_MINUS resolved as shift (REL_LESSTHAN < AR_MINUS).
    Conflict between rule 29 and token AR_MUL resolved as shift (REL_LESSTHAN < AR_MUL).
    Conflict between rule 29 and token AR_DIV resolved as shift (REL_LESSTHAN < AR_DIV).
    Conflict between rule 29 and token AR_MOD resolved as shift (REL_LESSTHAN < AR_MOD).
    Conflict between rule 29 and token BITWISE_XOR resolved as shift (REL_LESSTHAN < BITWISE_XOR).
    Conflict between rule 29 and token BITWISE_AND resolved as shift (REL_LESSTHAN < BITWISE_AND).
    Conflict between rule 29 and token BITWISE_OR resolved as shift (REL_LESSTHAN < BITWISE_OR).
    Conflict between rule 29 and token LOG_COMPARE resolved as shift (REL_LESSTHAN < LOG_COMPARE).


State 81

   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   33     | expr REL_GREATERTHAN expr .  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN]
   34     | expr . REL_NOTEQUAL expr

    AR_PLUS      shift, and go to state 51
    AR_MINUS     shift, and go to state 52
    AR_MUL       shift, and go to state 53
    AR_DIV       shift, and go to state 54
    AR_MOD       shift, and go to state 55
    BITWISE_XOR  shift, and go to state 56
    BITWISE_AND  shift, and go to state 57
    BITWISE_OR   shift, and go to state 58
    LOG_COMPARE  shift, and go to state 59

    $default  reduce using rule 33 (expr)

    Conflict between rule 33 and token REL_LESSEQUAL resolved as reduce (%left REL_LESSEQUAL).
    Conflict between rule 33 and token REL_GREATEQUAL resolved as reduce (%left REL_GREATEQUAL).
    Conflict between rule 33 and token REL_EQUAL resolved as reduce (%left REL_EQUAL).
    Conflict between rule 33 and token REL_NOTEQUAL resolved as reduce (%left REL_NOTEQUAL).
    Conflict between rule 33 and token REL_LESSTHAN resolved as reduce (%left REL_LESSTHAN).
    Conflict between rule 33 and token REL_GREATERTHAN resolved as reduce (%left REL_GREATERTHAN).
    Conflict between rule 33 and token AR_PLUS resolved as shift (REL_GREATERTHAN < AR_PLUS).
    Conflict between rule 33 and token AR_MINUS resolved as shift (REL_GREATERTHAN < AR_MINUS).
    Conflict between rule 33 and token AR_MUL resolved as shift (REL_GREATERTHAN < AR_MUL).
    Conflict between rule 33 and token AR_DIV resolved as shift (REL_GREATERTHAN < AR_DIV).
    Conflict between rule 33 and token AR_MOD resolved as shift (REL_GREATERTHAN < AR_MOD).
    Conflict between rule 33 and token BITWISE_XOR resolved as shift (REL_GREATERTHAN < BITWISE_XOR).
    Conflict between rule 33 and token BITWISE_AND resolved as shift (REL_GREATERTHAN < BITWISE_AND).
    Conflict between rule 33 and token BITWISE_OR resolved as shift (REL_GREATERTHAN < BITWISE_OR).
    Conflict between rule 33 and token LOG_COMPARE resolved as shift (REL_GREATERTHAN < LOG_COMPARE).


State 82

   22 expr: expr AR_PLUS AR_PLUS .

    $default  reduce using rule 22 (expr)


State 83

   17 expr: expr . AR_PLUS expr
   17     | expr AR_PLUS expr .  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 59

    $default  reduce using rule 17 (expr)

    Conflict between rule 17 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < AR_PLUS).
    Conflict between rule 17 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < AR_PLUS).
    Conflict between rule 17 and token REL_EQUAL resolved as reduce (REL_EQUAL < AR_PLUS).
    Conflict between rule 17 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < AR_PLUS).
    Conflict between rule 17 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < AR_PLUS).
    Conflict between rule 17 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < AR_PLUS).
    Conflict between rule 17 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 17 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 17 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 17 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 17 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 17 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 17 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 17 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 17 and token LOG_COMPARE resolved as shift (AR_PLUS < LOG_COMPARE).


State 84

   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   18     | expr AR_MINUS expr .  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 59

    $default  reduce using rule 18 (expr)

    Conflict between rule 18 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < AR_MINUS).
    Conflict between rule 18 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < AR_MINUS).
    Conflict between rule 18 and token REL_EQUAL resolved as reduce (REL_EQUAL < AR_MINUS).
    Conflict between rule 18 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < AR_MINUS).
    Conflict between rule 18 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < AR_MINUS).
    Conflict between rule 18 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < AR_MINUS).
    Conflict between rule 18 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 18 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 18 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 18 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 18 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 18 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 18 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 18 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 18 and token LOG_COMPARE resolved as shift (AR_MINUS < LOG_COMPARE).


State 85

   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   19     | expr AR_MUL expr .  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 59

    $default  reduce using rule 19 (expr)

    Conflict between rule 19 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < AR_MUL).
    Conflict between rule 19 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < AR_MUL).
    Conflict between rule 19 and token REL_EQUAL resolved as reduce (REL_EQUAL < AR_MUL).
    Conflict between rule 19 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < AR_MUL).
    Conflict between rule 19 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < AR_MUL).
    Conflict between rule 19 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < AR_MUL).
    Conflict between rule 19 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 19 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 19 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 19 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 19 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 19 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 19 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 19 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 19 and token LOG_COMPARE resolved as shift (AR_MUL < LOG_COMPARE).


State 86

   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   20     | expr AR_DIV expr .  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 59

    $default  reduce using rule 20 (expr)

    Conflict between rule 20 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < AR_DIV).
    Conflict between rule 20 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < AR_DIV).
    Conflict between rule 20 and token REL_EQUAL resolved as reduce (REL_EQUAL < AR_DIV).
    Conflict between rule 20 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < AR_DIV).
    Conflict between rule 20 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < AR_DIV).
    Conflict between rule 20 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < AR_DIV).
    Conflict between rule 20 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 20 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 20 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 20 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 20 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 20 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 20 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 20 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 20 and token LOG_COMPARE resolved as shift (AR_DIV < LOG_COMPARE).


State 87

   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   21     | expr AR_MOD expr .  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 59

    $default  reduce using rule 21 (expr)

    Conflict between rule 21 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < AR_MOD).
    Conflict between rule 21 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < AR_MOD).
    Conflict between rule 21 and token REL_EQUAL resolved as reduce (REL_EQUAL < AR_MOD).
    Conflict between rule 21 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < AR_MOD).
    Conflict between rule 21 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < AR_MOD).
    Conflict between rule 21 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < AR_MOD).
    Conflict between rule 21 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 21 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 21 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 21 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 21 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 21 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 21 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 21 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 21 and token LOG_COMPARE resolved as shift (AR_MOD < LOG_COMPARE).


State 88

   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   23     | expr BITWISE_XOR expr .  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 59

    $default  reduce using rule 23 (expr)

    Conflict between rule 23 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < BITWISE_XOR).
    Conflict between rule 23 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < BITWISE_XOR).
    Conflict between rule 23 and token REL_EQUAL resolved as reduce (REL_EQUAL < BITWISE_XOR).
    Conflict between rule 23 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < BITWISE_XOR).
    Conflict between rule 23 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < BITWISE_XOR).
    Conflict between rule 23 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < BITWISE_XOR).
    Conflict between rule 23 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 23 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 23 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 23 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 23 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 23 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 23 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 23 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 23 and token LOG_COMPARE resolved as shift (BITWISE_XOR < LOG_COMPARE).


State 89

   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   26     | expr BITWISE_AND BITWISE_AND . expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14

    $default  reduce using rule 38 (expr)

    expr  go to state 103


State 90

   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   25     | expr BITWISE_AND expr .  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 59

    $default  reduce using rule 25 (expr)

    Conflict between rule 25 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < BITWISE_AND).
    Conflict between rule 25 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < BITWISE_AND).
    Conflict between rule 25 and token REL_EQUAL resolved as reduce (REL_EQUAL < BITWISE_AND).
    Conflict between rule 25 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < BITWISE_AND).
    Conflict between rule 25 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < BITWISE_AND).
    Conflict between rule 25 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < BITWISE_AND).
    Conflict between rule 25 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 25 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 25 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 25 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 25 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 25 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 25 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 25 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 25 and token LOG_COMPARE resolved as shift (BITWISE_AND < LOG_COMPARE).


State 91

   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   27     | expr BITWISE_OR BITWISE_AND . expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14

    $default  reduce using rule 38 (expr)

    expr  go to state 104


State 92

   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   24     | expr BITWISE_OR expr .  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 59

    $default  reduce using rule 24 (expr)

    Conflict between rule 24 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < BITWISE_OR).
    Conflict between rule 24 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < BITWISE_OR).
    Conflict between rule 24 and token REL_EQUAL resolved as reduce (REL_EQUAL < BITWISE_OR).
    Conflict between rule 24 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < BITWISE_OR).
    Conflict between rule 24 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < BITWISE_OR).
    Conflict between rule 24 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < BITWISE_OR).
    Conflict between rule 24 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 24 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 24 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 24 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 24 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 24 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 24 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 24 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 24 and token LOG_COMPARE resolved as shift (BITWISE_OR < LOG_COMPARE).


State 93

   17 expr: . expr AR_PLUS expr
   18     | . expr AR_MINUS expr
   19     | . expr AR_MUL expr
   20     | . expr AR_DIV expr
   21     | . expr AR_MOD expr
   22     | . expr AR_PLUS AR_PLUS
   23     | . expr BITWISE_XOR expr
   24     | . expr BITWISE_OR expr
   25     | . expr BITWISE_AND expr
   26     | . expr BITWISE_AND BITWISE_AND expr
   27     | . expr BITWISE_OR BITWISE_AND expr
   28     | . expr LOG_COMPARE LOG_COMPARE expr
   28     | expr LOG_COMPARE LOG_COMPARE . expr
   29     | . expr REL_LESSTHAN expr
   30     | . expr REL_LESSEQUAL expr
   31     | . expr REL_EQUAL expr
   32     | . expr REL_GREATEQUAL expr
   33     | . expr REL_GREATERTHAN expr
   34     | . expr REL_NOTEQUAL expr
   35     | . NUM_INTEGER
   36     | . NUM_FLOAT
   37     | . IDENTIFIER
   38     | . %empty  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 67
    NUM_INTEGER  shift, and go to state 13
    NUM_FLOAT    shift, and go to state 14

    $default  reduce using rule 38 (expr)

    expr  go to state 105


State 94

   39 datatype: . FLOAT
   40         | . DOUBLE
   41         | . CHAR
   42         | . UNSIGNED CHAR
   43         | . INT
   44         | . UNSIGNED INT
   45         | . SHORT INT
   46         | . SHORT UNSIGNED INT
   47         | . LONG INT
   48         | . LONG UNSIGNED INT
   49         | . "void"
   65 arg: . datatype IDENTIFIER
   66    | . arg ','
   67 func_dec: datatype IDENTIFIER L_PAREN . arg R_PAREN

    CHAR      shift, and go to state 1
    INT       shift, and go to state 2
    FLOAT     shift, and go to state 3
    DOUBLE    shift, and go to state 4
    SHORT     shift, and go to state 5
    UNSIGNED  shift, and go to state 6
    LONG      shift, and go to state 7
    "void"    shift, and go to state 15

    datatype  go to state 106
    arg       go to state 107


State 95

   52 var_def: var_dec '=' NUM_INTEGER .

    $default  reduce using rule 52 (var_def)


State 96

   51 var_def: var_dec '=' NUM_FLOAT .

    $default  reduce using rule 51 (var_def)


State 97

   59 else: ELSE . L_FLOWER_BRKT block R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 38


State 98

   63 if_else_if: if else_if else .

    $default  reduce using rule 63 (if_else_if)


State 99

   58 if: IF L_PAREN expr R_PAREN . L_FLOWER_BRKT block R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 108


State 100

   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr
   60 else_if: ELSE IF L_FLOWER_BRKT expr . R_FLOWER_BRKT L_FLOWER_BRKT block R_FLOWER_BRKT

    R_FLOWER_BRKT    shift, and go to state 109
    REL_LESSEQUAL    shift, and go to state 45
    REL_GREATEQUAL   shift, and go to state 46
    REL_EQUAL        shift, and go to state 47
    REL_NOTEQUAL     shift, and go to state 48
    REL_LESSTHAN     shift, and go to state 49
    REL_GREATERTHAN  shift, and go to state 50
    AR_PLUS          shift, and go to state 51
    AR_MINUS         shift, and go to state 52
    AR_MUL           shift, and go to state 53
    AR_DIV           shift, and go to state 54
    AR_MOD           shift, and go to state 55
    BITWISE_XOR      shift, and go to state 56
    BITWISE_AND      shift, and go to state 57
    BITWISE_OR       shift, and go to state 58
    LOG_COMPARE      shift, and go to state 59


State 101

   59 else: ELSE L_FLOWER_BRKT block R_FLOWER_BRKT .

    $default  reduce using rule 59 (else)


State 102

   64 while: WHILE L_PAREN expr R_PAREN . L_FLOWER_BRKT block R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 110


State 103

   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   26     | expr BITWISE_AND BITWISE_AND expr .  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 59

    $default  reduce using rule 26 (expr)

    Conflict between rule 26 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < BITWISE_AND).
    Conflict between rule 26 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < BITWISE_AND).
    Conflict between rule 26 and token REL_EQUAL resolved as reduce (REL_EQUAL < BITWISE_AND).
    Conflict between rule 26 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < BITWISE_AND).
    Conflict between rule 26 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < BITWISE_AND).
    Conflict between rule 26 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < BITWISE_AND).
    Conflict between rule 26 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 26 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 26 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 26 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 26 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 26 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 26 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 26 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 26 and token LOG_COMPARE resolved as shift (BITWISE_AND < LOG_COMPARE).


State 104

   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   27     | expr BITWISE_OR BITWISE_AND expr .  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 59

    $default  reduce using rule 27 (expr)

    Conflict between rule 27 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < BITWISE_AND).
    Conflict between rule 27 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < BITWISE_AND).
    Conflict between rule 27 and token REL_EQUAL resolved as reduce (REL_EQUAL < BITWISE_AND).
    Conflict between rule 27 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < BITWISE_AND).
    Conflict between rule 27 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < BITWISE_AND).
    Conflict between rule 27 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < BITWISE_AND).
    Conflict between rule 27 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 27 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 27 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 27 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 27 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 27 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 27 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 27 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 27 and token LOG_COMPARE resolved as shift (BITWISE_AND < LOG_COMPARE).


State 105

   17 expr: expr . AR_PLUS expr
   18     | expr . AR_MINUS expr
   19     | expr . AR_MUL expr
   20     | expr . AR_DIV expr
   21     | expr . AR_MOD expr
   22     | expr . AR_PLUS AR_PLUS
   23     | expr . BITWISE_XOR expr
   24     | expr . BITWISE_OR expr
   25     | expr . BITWISE_AND expr
   26     | expr . BITWISE_AND BITWISE_AND expr
   27     | expr . BITWISE_OR BITWISE_AND expr
   28     | expr . LOG_COMPARE LOG_COMPARE expr
   28     | expr LOG_COMPARE LOG_COMPARE expr .  [$end, R_FLOWER_BRKT, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]
   29     | expr . REL_LESSTHAN expr
   30     | expr . REL_LESSEQUAL expr
   31     | expr . REL_EQUAL expr
   32     | expr . REL_GREATEQUAL expr
   33     | expr . REL_GREATERTHAN expr
   34     | expr . REL_NOTEQUAL expr

    $default  reduce using rule 28 (expr)

    Conflict between rule 28 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < LOG_COMPARE).
    Conflict between rule 28 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < LOG_COMPARE).
    Conflict between rule 28 and token REL_EQUAL resolved as reduce (REL_EQUAL < LOG_COMPARE).
    Conflict between rule 28 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < LOG_COMPARE).
    Conflict between rule 28 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < LOG_COMPARE).
    Conflict between rule 28 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < LOG_COMPARE).
    Conflict between rule 28 and token AR_PLUS resolved as reduce (AR_PLUS < LOG_COMPARE).
    Conflict between rule 28 and token AR_MINUS resolved as reduce (AR_MINUS < LOG_COMPARE).
    Conflict between rule 28 and token AR_MUL resolved as reduce (AR_MUL < LOG_COMPARE).
    Conflict between rule 28 and token AR_DIV resolved as reduce (AR_DIV < LOG_COMPARE).
    Conflict between rule 28 and token AR_MOD resolved as reduce (AR_MOD < LOG_COMPARE).
    Conflict between rule 28 and token BITWISE_XOR resolved as reduce (BITWISE_XOR < LOG_COMPARE).
    Conflict between rule 28 and token BITWISE_AND resolved as reduce (BITWISE_AND < LOG_COMPARE).
    Conflict between rule 28 and token BITWISE_OR resolved as reduce (BITWISE_OR < LOG_COMPARE).
    Conflict between rule 28 and token LOG_COMPARE resolved as reduce (%left LOG_COMPARE).


State 106

   65 arg: datatype . IDENTIFIER

    IDENTIFIER  shift, and go to state 111


State 107

   66 arg: arg . ','
   67 func_dec: datatype IDENTIFIER L_PAREN arg . R_PAREN

    R_PAREN  shift, and go to state 112
    ','      shift, and go to state 113


State 108

   55 block: . L_FLOWER_BRKT R_FLOWER_BRKT
   56      | . L_FLOWER_BRKT block R_FLOWER_BRKT
   57      | . L_FLOWER_BRKT "blah!" R_FLOWER_BRKT
   58 if: IF L_PAREN expr R_PAREN L_FLOWER_BRKT . block R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 11

    block  go to state 114


State 109

   60 else_if: ELSE IF L_FLOWER_BRKT expr R_FLOWER_BRKT . L_FLOWER_BRKT block R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 115


State 110

   55 block: . L_FLOWER_BRKT R_FLOWER_BRKT
   56      | . L_FLOWER_BRKT block R_FLOWER_BRKT
   57      | . L_FLOWER_BRKT "blah!" R_FLOWER_BRKT
   64 while: WHILE L_PAREN expr R_PAREN L_FLOWER_BRKT . block R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 11

    block  go to state 116


State 111

   65 arg: datatype IDENTIFIER .

    $default  reduce using rule 65 (arg)


State 112

   67 func_dec: datatype IDENTIFIER L_PAREN arg R_PAREN .

    $default  reduce using rule 67 (func_dec)


State 113

   66 arg: arg ',' .

    $default  reduce using rule 66 (arg)


State 114

   58 if: IF L_PAREN expr R_PAREN L_FLOWER_BRKT block . R_FLOWER_BRKT

    R_FLOWER_BRKT  shift, and go to state 117


State 115

   55 block: . L_FLOWER_BRKT R_FLOWER_BRKT
   56      | . L_FLOWER_BRKT block R_FLOWER_BRKT
   57      | . L_FLOWER_BRKT "blah!" R_FLOWER_BRKT
   60 else_if: ELSE IF L_FLOWER_BRKT expr R_FLOWER_BRKT L_FLOWER_BRKT . block R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 11

    block  go to state 118


State 116

   64 while: WHILE L_PAREN expr R_PAREN L_FLOWER_BRKT block . R_FLOWER_BRKT

    R_FLOWER_BRKT  shift, and go to state 119


State 117

   58 if: IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT .

    $default  reduce using rule 58 (if)


State 118

   60 else_if: ELSE IF L_FLOWER_BRKT expr R_FLOWER_BRKT L_FLOWER_BRKT block . R_FLOWER_BRKT

    R_FLOWER_BRKT  shift, and go to state 120


State 119

   64 while: WHILE L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT .

    $default  reduce using rule 64 (while)


State 120

   60 else_if: ELSE IF L_FLOWER_BRKT expr R_FLOWER_BRKT L_FLOWER_BRKT block R_FLOWER_BRKT .

    $default  reduce using rule 60 (else_if)
