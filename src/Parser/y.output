Terminals unused in grammar

   RETURN
   STRING
   LOG_AND
   LOG_OR


Rules useless in parser due to conflicts

   49 var_def: %empty

   54 else_if: else_if


State 0 conflicts: 1 reduce/reduce
State 44 conflicts: 1 shift/reduce
State 50 conflicts: 1 shift/reduce
State 51 conflicts: 1 shift/reduce
State 103 conflicts: 1 shift/reduce


Grammar

    0 $accept: ED $end

    1 ED: expr
    2   | block
    3   | datatype
    4   | var_dec
    5   | var_def
    6   | while
    7   | func_dec
    8   | func_def
    9   | if_elses

   10 expr: expr AR_PLUS expr
   11     | expr AR_MINUS expr
   12     | expr AR_MUL expr
   13     | expr AR_DIV expr
   14     | expr AR_MOD expr
   15     | expr AR_PLUS AR_PLUS
   16     | expr BITWISE_XOR expr
   17     | expr BITWISE_OR expr
   18     | expr BITWISE_AND expr
   19     | expr BITWISE_AND BITWISE_AND expr
   20     | expr BITWISE_OR BITWISE_AND expr
   21     | expr LOG_COMPARE LOG_COMPARE expr
   22     | expr REL_LESSTHAN expr
   23     | expr REL_LESSEQUAL expr
   24     | expr REL_EQUAL expr
   25     | expr REL_GREATEQUAL expr
   26     | expr REL_GREATERTHAN expr
   27     | expr REL_NOTEQUAL expr
   28     | NUM_INTEGER
   29     | NUM_FLOAT
   30     | IDENTIFIER
   31     | %empty

   32 datatype: FLOAT
   33         | DOUBLE
   34         | CHAR
   35         | UNSIGNED CHAR
   36         | INT
   37         | UNSIGNED INT
   38         | SHORT INT
   39         | SHORT UNSIGNED INT
   40         | LONG INT
   41         | LONG UNSIGNED INT
   42         | "void"

   43 var_dec: datatype IDENTIFIER
   44        | %empty

   45 var_def: var_dec '=' NUM_FLOAT
   46        | var_dec '=' NUM_INTEGER
   47        | IDENTIFIER '=' NUM_FLOAT
   48        | IDENTIFIER '=' NUM_INTEGER
   49        | %empty

   50 block: L_FLOWER_BRKT R_FLOWER_BRKT
   51      | L_FLOWER_BRKT block R_FLOWER_BRKT
   52      | L_FLOWER_BRKT "blah!" R_FLOWER_BRKT

   53 else_if: ELSE L_FLOWER_BRKT block R_FLOWER_BRKT IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT
   54        | else_if

   55 if_elses: IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT else_if ELSE L_FLOWER_BRKT block R_FLOWER_BRKT
   56         | IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

   57 while: WHILE L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

   58 arg: datatype IDENTIFIER
   59    | arg ','

   60 func_dec: datatype IDENTIFIER L_PAREN arg R_PAREN

   61 func_def: func_dec block


Terminals, with rules where they appear

$end (0) 0
',' (44) 59
'=' (61) 45 46 47 48
error (256)
CHAR (258) 34 35
INT (259) 36 37 38 39 40 41
FLOAT (260) 32
DOUBLE (261) 33
SHORT (262) 38 39
UNSIGNED (263) 35 37 39 41
LONG (264) 40 41
RETURN (265)
IF (266) 53 55 56
ELSE (267) 53 55
WHILE (268) 57
L_FLOWER_BRKT (269) 50 51 52 53 55 56 57
R_FLOWER_BRKT (270) 50 51 52 53 55 56 57
L_PAREN (271) 53 55 56 57 60
R_PAREN (272) 53 55 56 57 60
STRING (273)
IDENTIFIER (274) 30 43 47 48 58 60
NUM_INTEGER (275) 28 46 48
NUM_FLOAT (276) 29 45 47
REL_LESSEQUAL (277) 23
REL_GREATEQUAL (278) 25
REL_EQUAL (279) 24
REL_NOTEQUAL (280) 27
REL_LESSTHAN (281) 22
REL_GREATERTHAN (282) 26
AR_PLUS (283) 10 15
AR_MINUS (284) 11
AR_MUL (285) 12
AR_DIV (286) 13
AR_MOD (287) 14
BITWISE_XOR (288) 16
BITWISE_AND (289) 18 19 20
BITWISE_OR (290) 17 20
LOG_AND (291)
LOG_OR (292)
LOG_COMPARE (293) 21
"void" (294) 42
"blah!" (295) 52


Nonterminals, with rules where they appear

$accept (43)
    on left: 0
ED (44)
    on left: 1 2 3 4 5 6 7 8 9, on right: 0
expr (45)
    on left: 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27
    28 29 30 31, on right: 1 10 11 12 13 14 15 16 17 18 19 20 21 22
    23 24 25 26 27 53 55 56 57
datatype (46)
    on left: 32 33 34 35 36 37 38 39 40 41 42, on right: 3 43 58 60
var_dec (47)
    on left: 43 44, on right: 4 45 46
var_def (48)
    on left: 45 46 47 48 49, on right: 5
block (49)
    on left: 50 51 52, on right: 2 51 53 55 56 57 61
else_if (50)
    on left: 53 54, on right: 54 55
if_elses (51)
    on left: 55 56, on right: 9
while (52)
    on left: 57, on right: 6
arg (53)
    on left: 58 59, on right: 59 60
func_dec (54)
    on left: 60, on right: 7 61
func_def (55)
    on left: 61, on right: 8


State 0

    0 $accept: . ED $end
    1 ED: . expr
    2   | . block
    3   | . datatype
    4   | . var_dec
    5   | . var_def
    6   | . while
    7   | . func_dec
    8   | . func_def
    9   | . if_elses
   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [$end, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]
   32 datatype: . FLOAT
   33         | . DOUBLE
   34         | . CHAR
   35         | . UNSIGNED CHAR
   36         | . INT
   37         | . UNSIGNED INT
   38         | . SHORT INT
   39         | . SHORT UNSIGNED INT
   40         | . LONG INT
   41         | . LONG UNSIGNED INT
   42         | . "void"
   43 var_dec: . datatype IDENTIFIER
   44        | . %empty  [$end, '=']
   45 var_def: . var_dec '=' NUM_FLOAT
   46        | . var_dec '=' NUM_INTEGER
   47        | . IDENTIFIER '=' NUM_FLOAT
   48        | . IDENTIFIER '=' NUM_INTEGER
   49        | . %empty  [$end]
   50 block: . L_FLOWER_BRKT R_FLOWER_BRKT
   51      | . L_FLOWER_BRKT block R_FLOWER_BRKT
   52      | . L_FLOWER_BRKT "blah!" R_FLOWER_BRKT
   55 if_elses: . IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT else_if ELSE L_FLOWER_BRKT block R_FLOWER_BRKT
   56         | . IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT
   57 while: . WHILE L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT
   60 func_dec: . datatype IDENTIFIER L_PAREN arg R_PAREN
   61 func_def: . func_dec block

    CHAR           shift, and go to state 1
    INT            shift, and go to state 2
    FLOAT          shift, and go to state 3
    DOUBLE         shift, and go to state 4
    SHORT          shift, and go to state 5
    UNSIGNED       shift, and go to state 6
    LONG           shift, and go to state 7
    IF             shift, and go to state 8
    WHILE          shift, and go to state 9
    L_FLOWER_BRKT  shift, and go to state 10
    IDENTIFIER     shift, and go to state 11
    NUM_INTEGER    shift, and go to state 12
    NUM_FLOAT      shift, and go to state 13
    "void"         shift, and go to state 14

    $end      reduce using rule 31 (expr)
    $end      [reduce using rule 44 (var_dec)]
    $end      [reduce using rule 49 (var_def)]
    '='       reduce using rule 44 (var_dec)
    $default  reduce using rule 31 (expr)

    ED        go to state 15
    expr      go to state 16
    datatype  go to state 17
    var_dec   go to state 18
    var_def   go to state 19
    block     go to state 20
    if_elses  go to state 21
    while     go to state 22
    func_dec  go to state 23
    func_def  go to state 24


State 1

   34 datatype: CHAR .

    $default  reduce using rule 34 (datatype)


State 2

   36 datatype: INT .

    $default  reduce using rule 36 (datatype)


State 3

   32 datatype: FLOAT .

    $default  reduce using rule 32 (datatype)


State 4

   33 datatype: DOUBLE .

    $default  reduce using rule 33 (datatype)


State 5

   38 datatype: SHORT . INT
   39         | SHORT . UNSIGNED INT

    INT       shift, and go to state 25
    UNSIGNED  shift, and go to state 26


State 6

   35 datatype: UNSIGNED . CHAR
   37         | UNSIGNED . INT

    CHAR  shift, and go to state 27
    INT   shift, and go to state 28


State 7

   40 datatype: LONG . INT
   41         | LONG . UNSIGNED INT

    INT       shift, and go to state 29
    UNSIGNED  shift, and go to state 30


State 8

   55 if_elses: IF . L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT else_if ELSE L_FLOWER_BRKT block R_FLOWER_BRKT
   56         | IF . L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

    L_PAREN  shift, and go to state 31


State 9

   57 while: WHILE . L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

    L_PAREN  shift, and go to state 32


State 10

   50 block: . L_FLOWER_BRKT R_FLOWER_BRKT
   50      | L_FLOWER_BRKT . R_FLOWER_BRKT
   51      | . L_FLOWER_BRKT block R_FLOWER_BRKT
   51      | L_FLOWER_BRKT . block R_FLOWER_BRKT
   52      | . L_FLOWER_BRKT "blah!" R_FLOWER_BRKT
   52      | L_FLOWER_BRKT . "blah!" R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 10
    R_FLOWER_BRKT  shift, and go to state 33
    "blah!"        shift, and go to state 34

    block  go to state 35


State 11

   30 expr: IDENTIFIER .  [$end, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]
   47 var_def: IDENTIFIER . '=' NUM_FLOAT
   48        | IDENTIFIER . '=' NUM_INTEGER

    '='  shift, and go to state 36

    $default  reduce using rule 30 (expr)


State 12

   28 expr: NUM_INTEGER .

    $default  reduce using rule 28 (expr)


State 13

   29 expr: NUM_FLOAT .

    $default  reduce using rule 29 (expr)


State 14

   42 datatype: "void" .

    $default  reduce using rule 42 (datatype)


State 15

    0 $accept: ED . $end

    $end  shift, and go to state 37


State 16

    1 ED: expr .  [$end]
   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr

    REL_LESSEQUAL    shift, and go to state 38
    REL_GREATEQUAL   shift, and go to state 39
    REL_EQUAL        shift, and go to state 40
    REL_NOTEQUAL     shift, and go to state 41
    REL_LESSTHAN     shift, and go to state 42
    REL_GREATERTHAN  shift, and go to state 43
    AR_PLUS          shift, and go to state 44
    AR_MINUS         shift, and go to state 45
    AR_MUL           shift, and go to state 46
    AR_DIV           shift, and go to state 47
    AR_MOD           shift, and go to state 48
    BITWISE_XOR      shift, and go to state 49
    BITWISE_AND      shift, and go to state 50
    BITWISE_OR       shift, and go to state 51
    LOG_COMPARE      shift, and go to state 52

    $default  reduce using rule 1 (ED)


State 17

    3 ED: datatype .  [$end]
   43 var_dec: datatype . IDENTIFIER
   60 func_dec: datatype . IDENTIFIER L_PAREN arg R_PAREN

    IDENTIFIER  shift, and go to state 53

    $default  reduce using rule 3 (ED)


State 18

    4 ED: var_dec .  [$end]
   45 var_def: var_dec . '=' NUM_FLOAT
   46        | var_dec . '=' NUM_INTEGER

    '='  shift, and go to state 54

    $default  reduce using rule 4 (ED)


State 19

    5 ED: var_def .

    $default  reduce using rule 5 (ED)


State 20

    2 ED: block .

    $default  reduce using rule 2 (ED)


State 21

    9 ED: if_elses .

    $default  reduce using rule 9 (ED)


State 22

    6 ED: while .

    $default  reduce using rule 6 (ED)


State 23

    7 ED: func_dec .  [$end]
   50 block: . L_FLOWER_BRKT R_FLOWER_BRKT
   51      | . L_FLOWER_BRKT block R_FLOWER_BRKT
   52      | . L_FLOWER_BRKT "blah!" R_FLOWER_BRKT
   61 func_def: func_dec . block

    L_FLOWER_BRKT  shift, and go to state 10

    $default  reduce using rule 7 (ED)

    block  go to state 55


State 24

    8 ED: func_def .

    $default  reduce using rule 8 (ED)


State 25

   38 datatype: SHORT INT .

    $default  reduce using rule 38 (datatype)


State 26

   39 datatype: SHORT UNSIGNED . INT

    INT  shift, and go to state 56


State 27

   35 datatype: UNSIGNED CHAR .

    $default  reduce using rule 35 (datatype)


State 28

   37 datatype: UNSIGNED INT .

    $default  reduce using rule 37 (datatype)


State 29

   40 datatype: LONG INT .

    $default  reduce using rule 40 (datatype)


State 30

   41 datatype: LONG UNSIGNED . INT

    INT  shift, and go to state 57


State 31

   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]
   55 if_elses: IF L_PAREN . expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT else_if ELSE L_FLOWER_BRKT block R_FLOWER_BRKT
   56         | IF L_PAREN . expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13

    $default  reduce using rule 31 (expr)

    expr  go to state 59


State 32

   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]
   57 while: WHILE L_PAREN . expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13

    $default  reduce using rule 31 (expr)

    expr  go to state 60


State 33

   50 block: L_FLOWER_BRKT R_FLOWER_BRKT .

    $default  reduce using rule 50 (block)


State 34

   52 block: L_FLOWER_BRKT "blah!" . R_FLOWER_BRKT

    R_FLOWER_BRKT  shift, and go to state 61


State 35

   51 block: L_FLOWER_BRKT block . R_FLOWER_BRKT

    R_FLOWER_BRKT  shift, and go to state 62


State 36

   47 var_def: IDENTIFIER '=' . NUM_FLOAT
   48        | IDENTIFIER '=' . NUM_INTEGER

    NUM_INTEGER  shift, and go to state 63
    NUM_FLOAT    shift, and go to state 64


State 37

    0 $accept: ED $end .

    $default  accept


State 38

   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   23     | expr REL_LESSEQUAL . expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13

    $default  reduce using rule 31 (expr)

    expr  go to state 65


State 39

   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   25     | expr REL_GREATEQUAL . expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13

    $default  reduce using rule 31 (expr)

    expr  go to state 66


State 40

   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   24     | expr REL_EQUAL . expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13

    $default  reduce using rule 31 (expr)

    expr  go to state 67


State 41

   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   27     | expr REL_NOTEQUAL . expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13

    $default  reduce using rule 31 (expr)

    expr  go to state 68


State 42

   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   22     | expr REL_LESSTHAN . expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13

    $default  reduce using rule 31 (expr)

    expr  go to state 69


State 43

   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   26     | expr REL_GREATERTHAN . expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13

    $default  reduce using rule 31 (expr)

    expr  go to state 70


State 44

   10 expr: . expr AR_PLUS expr
   10     | expr AR_PLUS . expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   15     | expr AR_PLUS . AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13
    AR_PLUS      shift, and go to state 71

    AR_PLUS   [reduce using rule 31 (expr)]
    $default  reduce using rule 31 (expr)

    expr  go to state 72


State 45

   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   11     | expr AR_MINUS . expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13

    $default  reduce using rule 31 (expr)

    expr  go to state 73


State 46

   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   12     | expr AR_MUL . expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13

    $default  reduce using rule 31 (expr)

    expr  go to state 74


State 47

   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   13     | expr AR_DIV . expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13

    $default  reduce using rule 31 (expr)

    expr  go to state 75


State 48

   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   14     | expr AR_MOD . expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13

    $default  reduce using rule 31 (expr)

    expr  go to state 76


State 49

   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   16     | expr BITWISE_XOR . expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13

    $default  reduce using rule 31 (expr)

    expr  go to state 77


State 50

   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   18     | expr BITWISE_AND . expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   19     | expr BITWISE_AND . BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13
    BITWISE_AND  shift, and go to state 78

    BITWISE_AND  [reduce using rule 31 (expr)]
    $default     reduce using rule 31 (expr)

    expr  go to state 79


State 51

   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   17     | expr BITWISE_OR . expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   20     | expr BITWISE_OR . BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13
    BITWISE_AND  shift, and go to state 80

    BITWISE_AND  [reduce using rule 31 (expr)]
    $default     reduce using rule 31 (expr)

    expr  go to state 81


State 52

   21 expr: expr LOG_COMPARE . LOG_COMPARE expr

    LOG_COMPARE  shift, and go to state 82


State 53

   43 var_dec: datatype IDENTIFIER .  [$end, '=']
   60 func_dec: datatype IDENTIFIER . L_PAREN arg R_PAREN

    L_PAREN  shift, and go to state 83

    $default  reduce using rule 43 (var_dec)


State 54

   45 var_def: var_dec '=' . NUM_FLOAT
   46        | var_dec '=' . NUM_INTEGER

    NUM_INTEGER  shift, and go to state 84
    NUM_FLOAT    shift, and go to state 85


State 55

   61 func_def: func_dec block .

    $default  reduce using rule 61 (func_def)


State 56

   39 datatype: SHORT UNSIGNED INT .

    $default  reduce using rule 39 (datatype)


State 57

   41 datatype: LONG UNSIGNED INT .

    $default  reduce using rule 41 (datatype)


State 58

   30 expr: IDENTIFIER .

    $default  reduce using rule 30 (expr)


State 59

   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr
   55 if_elses: IF L_PAREN expr . R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT else_if ELSE L_FLOWER_BRKT block R_FLOWER_BRKT
   56         | IF L_PAREN expr . R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

    R_PAREN          shift, and go to state 86
    REL_LESSEQUAL    shift, and go to state 38
    REL_GREATEQUAL   shift, and go to state 39
    REL_EQUAL        shift, and go to state 40
    REL_NOTEQUAL     shift, and go to state 41
    REL_LESSTHAN     shift, and go to state 42
    REL_GREATERTHAN  shift, and go to state 43
    AR_PLUS          shift, and go to state 44
    AR_MINUS         shift, and go to state 45
    AR_MUL           shift, and go to state 46
    AR_DIV           shift, and go to state 47
    AR_MOD           shift, and go to state 48
    BITWISE_XOR      shift, and go to state 49
    BITWISE_AND      shift, and go to state 50
    BITWISE_OR       shift, and go to state 51
    LOG_COMPARE      shift, and go to state 52


State 60

   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr
   57 while: WHILE L_PAREN expr . R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

    R_PAREN          shift, and go to state 87
    REL_LESSEQUAL    shift, and go to state 38
    REL_GREATEQUAL   shift, and go to state 39
    REL_EQUAL        shift, and go to state 40
    REL_NOTEQUAL     shift, and go to state 41
    REL_LESSTHAN     shift, and go to state 42
    REL_GREATERTHAN  shift, and go to state 43
    AR_PLUS          shift, and go to state 44
    AR_MINUS         shift, and go to state 45
    AR_MUL           shift, and go to state 46
    AR_DIV           shift, and go to state 47
    AR_MOD           shift, and go to state 48
    BITWISE_XOR      shift, and go to state 49
    BITWISE_AND      shift, and go to state 50
    BITWISE_OR       shift, and go to state 51
    LOG_COMPARE      shift, and go to state 52


State 61

   52 block: L_FLOWER_BRKT "blah!" R_FLOWER_BRKT .

    $default  reduce using rule 52 (block)


State 62

   51 block: L_FLOWER_BRKT block R_FLOWER_BRKT .

    $default  reduce using rule 51 (block)


State 63

   48 var_def: IDENTIFIER '=' NUM_INTEGER .

    $default  reduce using rule 48 (var_def)


State 64

   47 var_def: IDENTIFIER '=' NUM_FLOAT .

    $default  reduce using rule 47 (var_def)


State 65

   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   23     | expr REL_LESSEQUAL expr .  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN]
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr

    AR_PLUS      shift, and go to state 44
    AR_MINUS     shift, and go to state 45
    AR_MUL       shift, and go to state 46
    AR_DIV       shift, and go to state 47
    AR_MOD       shift, and go to state 48
    BITWISE_XOR  shift, and go to state 49
    BITWISE_AND  shift, and go to state 50
    BITWISE_OR   shift, and go to state 51
    LOG_COMPARE  shift, and go to state 52

    $default  reduce using rule 23 (expr)

    Conflict between rule 23 and token REL_LESSEQUAL resolved as reduce (%left REL_LESSEQUAL).
    Conflict between rule 23 and token REL_GREATEQUAL resolved as reduce (%left REL_GREATEQUAL).
    Conflict between rule 23 and token REL_EQUAL resolved as reduce (%left REL_EQUAL).
    Conflict between rule 23 and token REL_NOTEQUAL resolved as reduce (%left REL_NOTEQUAL).
    Conflict between rule 23 and token REL_LESSTHAN resolved as reduce (%left REL_LESSTHAN).
    Conflict between rule 23 and token REL_GREATERTHAN resolved as reduce (%left REL_GREATERTHAN).
    Conflict between rule 23 and token AR_PLUS resolved as shift (REL_LESSEQUAL < AR_PLUS).
    Conflict between rule 23 and token AR_MINUS resolved as shift (REL_LESSEQUAL < AR_MINUS).
    Conflict between rule 23 and token AR_MUL resolved as shift (REL_LESSEQUAL < AR_MUL).
    Conflict between rule 23 and token AR_DIV resolved as shift (REL_LESSEQUAL < AR_DIV).
    Conflict between rule 23 and token AR_MOD resolved as shift (REL_LESSEQUAL < AR_MOD).
    Conflict between rule 23 and token BITWISE_XOR resolved as shift (REL_LESSEQUAL < BITWISE_XOR).
    Conflict between rule 23 and token BITWISE_AND resolved as shift (REL_LESSEQUAL < BITWISE_AND).
    Conflict between rule 23 and token BITWISE_OR resolved as shift (REL_LESSEQUAL < BITWISE_OR).
    Conflict between rule 23 and token LOG_COMPARE resolved as shift (REL_LESSEQUAL < LOG_COMPARE).


State 66

   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   25     | expr REL_GREATEQUAL expr .  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN]
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr

    AR_PLUS      shift, and go to state 44
    AR_MINUS     shift, and go to state 45
    AR_MUL       shift, and go to state 46
    AR_DIV       shift, and go to state 47
    AR_MOD       shift, and go to state 48
    BITWISE_XOR  shift, and go to state 49
    BITWISE_AND  shift, and go to state 50
    BITWISE_OR   shift, and go to state 51
    LOG_COMPARE  shift, and go to state 52

    $default  reduce using rule 25 (expr)

    Conflict between rule 25 and token REL_LESSEQUAL resolved as reduce (%left REL_LESSEQUAL).
    Conflict between rule 25 and token REL_GREATEQUAL resolved as reduce (%left REL_GREATEQUAL).
    Conflict between rule 25 and token REL_EQUAL resolved as reduce (%left REL_EQUAL).
    Conflict between rule 25 and token REL_NOTEQUAL resolved as reduce (%left REL_NOTEQUAL).
    Conflict between rule 25 and token REL_LESSTHAN resolved as reduce (%left REL_LESSTHAN).
    Conflict between rule 25 and token REL_GREATERTHAN resolved as reduce (%left REL_GREATERTHAN).
    Conflict between rule 25 and token AR_PLUS resolved as shift (REL_GREATEQUAL < AR_PLUS).
    Conflict between rule 25 and token AR_MINUS resolved as shift (REL_GREATEQUAL < AR_MINUS).
    Conflict between rule 25 and token AR_MUL resolved as shift (REL_GREATEQUAL < AR_MUL).
    Conflict between rule 25 and token AR_DIV resolved as shift (REL_GREATEQUAL < AR_DIV).
    Conflict between rule 25 and token AR_MOD resolved as shift (REL_GREATEQUAL < AR_MOD).
    Conflict between rule 25 and token BITWISE_XOR resolved as shift (REL_GREATEQUAL < BITWISE_XOR).
    Conflict between rule 25 and token BITWISE_AND resolved as shift (REL_GREATEQUAL < BITWISE_AND).
    Conflict between rule 25 and token BITWISE_OR resolved as shift (REL_GREATEQUAL < BITWISE_OR).
    Conflict between rule 25 and token LOG_COMPARE resolved as shift (REL_GREATEQUAL < LOG_COMPARE).


State 67

   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   24     | expr REL_EQUAL expr .  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN]
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr

    AR_PLUS      shift, and go to state 44
    AR_MINUS     shift, and go to state 45
    AR_MUL       shift, and go to state 46
    AR_DIV       shift, and go to state 47
    AR_MOD       shift, and go to state 48
    BITWISE_XOR  shift, and go to state 49
    BITWISE_AND  shift, and go to state 50
    BITWISE_OR   shift, and go to state 51
    LOG_COMPARE  shift, and go to state 52

    $default  reduce using rule 24 (expr)

    Conflict between rule 24 and token REL_LESSEQUAL resolved as reduce (%left REL_LESSEQUAL).
    Conflict between rule 24 and token REL_GREATEQUAL resolved as reduce (%left REL_GREATEQUAL).
    Conflict between rule 24 and token REL_EQUAL resolved as reduce (%left REL_EQUAL).
    Conflict between rule 24 and token REL_NOTEQUAL resolved as reduce (%left REL_NOTEQUAL).
    Conflict between rule 24 and token REL_LESSTHAN resolved as reduce (%left REL_LESSTHAN).
    Conflict between rule 24 and token REL_GREATERTHAN resolved as reduce (%left REL_GREATERTHAN).
    Conflict between rule 24 and token AR_PLUS resolved as shift (REL_EQUAL < AR_PLUS).
    Conflict between rule 24 and token AR_MINUS resolved as shift (REL_EQUAL < AR_MINUS).
    Conflict between rule 24 and token AR_MUL resolved as shift (REL_EQUAL < AR_MUL).
    Conflict between rule 24 and token AR_DIV resolved as shift (REL_EQUAL < AR_DIV).
    Conflict between rule 24 and token AR_MOD resolved as shift (REL_EQUAL < AR_MOD).
    Conflict between rule 24 and token BITWISE_XOR resolved as shift (REL_EQUAL < BITWISE_XOR).
    Conflict between rule 24 and token BITWISE_AND resolved as shift (REL_EQUAL < BITWISE_AND).
    Conflict between rule 24 and token BITWISE_OR resolved as shift (REL_EQUAL < BITWISE_OR).
    Conflict between rule 24 and token LOG_COMPARE resolved as shift (REL_EQUAL < LOG_COMPARE).


State 68

   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr
   27     | expr REL_NOTEQUAL expr .  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN]

    AR_PLUS      shift, and go to state 44
    AR_MINUS     shift, and go to state 45
    AR_MUL       shift, and go to state 46
    AR_DIV       shift, and go to state 47
    AR_MOD       shift, and go to state 48
    BITWISE_XOR  shift, and go to state 49
    BITWISE_AND  shift, and go to state 50
    BITWISE_OR   shift, and go to state 51
    LOG_COMPARE  shift, and go to state 52

    $default  reduce using rule 27 (expr)

    Conflict between rule 27 and token REL_LESSEQUAL resolved as reduce (%left REL_LESSEQUAL).
    Conflict between rule 27 and token REL_GREATEQUAL resolved as reduce (%left REL_GREATEQUAL).
    Conflict between rule 27 and token REL_EQUAL resolved as reduce (%left REL_EQUAL).
    Conflict between rule 27 and token REL_NOTEQUAL resolved as reduce (%left REL_NOTEQUAL).
    Conflict between rule 27 and token REL_LESSTHAN resolved as reduce (%left REL_LESSTHAN).
    Conflict between rule 27 and token REL_GREATERTHAN resolved as reduce (%left REL_GREATERTHAN).
    Conflict between rule 27 and token AR_PLUS resolved as shift (REL_NOTEQUAL < AR_PLUS).
    Conflict between rule 27 and token AR_MINUS resolved as shift (REL_NOTEQUAL < AR_MINUS).
    Conflict between rule 27 and token AR_MUL resolved as shift (REL_NOTEQUAL < AR_MUL).
    Conflict between rule 27 and token AR_DIV resolved as shift (REL_NOTEQUAL < AR_DIV).
    Conflict between rule 27 and token AR_MOD resolved as shift (REL_NOTEQUAL < AR_MOD).
    Conflict between rule 27 and token BITWISE_XOR resolved as shift (REL_NOTEQUAL < BITWISE_XOR).
    Conflict between rule 27 and token BITWISE_AND resolved as shift (REL_NOTEQUAL < BITWISE_AND).
    Conflict between rule 27 and token BITWISE_OR resolved as shift (REL_NOTEQUAL < BITWISE_OR).
    Conflict between rule 27 and token LOG_COMPARE resolved as shift (REL_NOTEQUAL < LOG_COMPARE).


State 69

   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   22     | expr REL_LESSTHAN expr .  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN]
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr

    AR_PLUS      shift, and go to state 44
    AR_MINUS     shift, and go to state 45
    AR_MUL       shift, and go to state 46
    AR_DIV       shift, and go to state 47
    AR_MOD       shift, and go to state 48
    BITWISE_XOR  shift, and go to state 49
    BITWISE_AND  shift, and go to state 50
    BITWISE_OR   shift, and go to state 51
    LOG_COMPARE  shift, and go to state 52

    $default  reduce using rule 22 (expr)

    Conflict between rule 22 and token REL_LESSEQUAL resolved as reduce (%left REL_LESSEQUAL).
    Conflict between rule 22 and token REL_GREATEQUAL resolved as reduce (%left REL_GREATEQUAL).
    Conflict between rule 22 and token REL_EQUAL resolved as reduce (%left REL_EQUAL).
    Conflict between rule 22 and token REL_NOTEQUAL resolved as reduce (%left REL_NOTEQUAL).
    Conflict between rule 22 and token REL_LESSTHAN resolved as reduce (%left REL_LESSTHAN).
    Conflict between rule 22 and token REL_GREATERTHAN resolved as reduce (%left REL_GREATERTHAN).
    Conflict between rule 22 and token AR_PLUS resolved as shift (REL_LESSTHAN < AR_PLUS).
    Conflict between rule 22 and token AR_MINUS resolved as shift (REL_LESSTHAN < AR_MINUS).
    Conflict between rule 22 and token AR_MUL resolved as shift (REL_LESSTHAN < AR_MUL).
    Conflict between rule 22 and token AR_DIV resolved as shift (REL_LESSTHAN < AR_DIV).
    Conflict between rule 22 and token AR_MOD resolved as shift (REL_LESSTHAN < AR_MOD).
    Conflict between rule 22 and token BITWISE_XOR resolved as shift (REL_LESSTHAN < BITWISE_XOR).
    Conflict between rule 22 and token BITWISE_AND resolved as shift (REL_LESSTHAN < BITWISE_AND).
    Conflict between rule 22 and token BITWISE_OR resolved as shift (REL_LESSTHAN < BITWISE_OR).
    Conflict between rule 22 and token LOG_COMPARE resolved as shift (REL_LESSTHAN < LOG_COMPARE).


State 70

   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   26     | expr REL_GREATERTHAN expr .  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN]
   27     | expr . REL_NOTEQUAL expr

    AR_PLUS      shift, and go to state 44
    AR_MINUS     shift, and go to state 45
    AR_MUL       shift, and go to state 46
    AR_DIV       shift, and go to state 47
    AR_MOD       shift, and go to state 48
    BITWISE_XOR  shift, and go to state 49
    BITWISE_AND  shift, and go to state 50
    BITWISE_OR   shift, and go to state 51
    LOG_COMPARE  shift, and go to state 52

    $default  reduce using rule 26 (expr)

    Conflict between rule 26 and token REL_LESSEQUAL resolved as reduce (%left REL_LESSEQUAL).
    Conflict between rule 26 and token REL_GREATEQUAL resolved as reduce (%left REL_GREATEQUAL).
    Conflict between rule 26 and token REL_EQUAL resolved as reduce (%left REL_EQUAL).
    Conflict between rule 26 and token REL_NOTEQUAL resolved as reduce (%left REL_NOTEQUAL).
    Conflict between rule 26 and token REL_LESSTHAN resolved as reduce (%left REL_LESSTHAN).
    Conflict between rule 26 and token REL_GREATERTHAN resolved as reduce (%left REL_GREATERTHAN).
    Conflict between rule 26 and token AR_PLUS resolved as shift (REL_GREATERTHAN < AR_PLUS).
    Conflict between rule 26 and token AR_MINUS resolved as shift (REL_GREATERTHAN < AR_MINUS).
    Conflict between rule 26 and token AR_MUL resolved as shift (REL_GREATERTHAN < AR_MUL).
    Conflict between rule 26 and token AR_DIV resolved as shift (REL_GREATERTHAN < AR_DIV).
    Conflict between rule 26 and token AR_MOD resolved as shift (REL_GREATERTHAN < AR_MOD).
    Conflict between rule 26 and token BITWISE_XOR resolved as shift (REL_GREATERTHAN < BITWISE_XOR).
    Conflict between rule 26 and token BITWISE_AND resolved as shift (REL_GREATERTHAN < BITWISE_AND).
    Conflict between rule 26 and token BITWISE_OR resolved as shift (REL_GREATERTHAN < BITWISE_OR).
    Conflict between rule 26 and token LOG_COMPARE resolved as shift (REL_GREATERTHAN < LOG_COMPARE).


State 71

   15 expr: expr AR_PLUS AR_PLUS .

    $default  reduce using rule 15 (expr)


State 72

   10 expr: expr . AR_PLUS expr
   10     | expr AR_PLUS expr .  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 52

    $default  reduce using rule 10 (expr)

    Conflict between rule 10 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < AR_PLUS).
    Conflict between rule 10 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < AR_PLUS).
    Conflict between rule 10 and token REL_EQUAL resolved as reduce (REL_EQUAL < AR_PLUS).
    Conflict between rule 10 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < AR_PLUS).
    Conflict between rule 10 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < AR_PLUS).
    Conflict between rule 10 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < AR_PLUS).
    Conflict between rule 10 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 10 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 10 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 10 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 10 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 10 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 10 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 10 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 10 and token LOG_COMPARE resolved as shift (AR_PLUS < LOG_COMPARE).


State 73

   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   11     | expr AR_MINUS expr .  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 52

    $default  reduce using rule 11 (expr)

    Conflict between rule 11 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < AR_MINUS).
    Conflict between rule 11 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < AR_MINUS).
    Conflict between rule 11 and token REL_EQUAL resolved as reduce (REL_EQUAL < AR_MINUS).
    Conflict between rule 11 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < AR_MINUS).
    Conflict between rule 11 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < AR_MINUS).
    Conflict between rule 11 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < AR_MINUS).
    Conflict between rule 11 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 11 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 11 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 11 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 11 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 11 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 11 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 11 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 11 and token LOG_COMPARE resolved as shift (AR_MINUS < LOG_COMPARE).


State 74

   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   12     | expr AR_MUL expr .  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 52

    $default  reduce using rule 12 (expr)

    Conflict between rule 12 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < AR_MUL).
    Conflict between rule 12 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < AR_MUL).
    Conflict between rule 12 and token REL_EQUAL resolved as reduce (REL_EQUAL < AR_MUL).
    Conflict between rule 12 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < AR_MUL).
    Conflict between rule 12 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < AR_MUL).
    Conflict between rule 12 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < AR_MUL).
    Conflict between rule 12 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 12 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 12 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 12 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 12 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 12 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 12 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 12 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 12 and token LOG_COMPARE resolved as shift (AR_MUL < LOG_COMPARE).


State 75

   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   13     | expr AR_DIV expr .  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 52

    $default  reduce using rule 13 (expr)

    Conflict between rule 13 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < AR_DIV).
    Conflict between rule 13 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < AR_DIV).
    Conflict between rule 13 and token REL_EQUAL resolved as reduce (REL_EQUAL < AR_DIV).
    Conflict between rule 13 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < AR_DIV).
    Conflict between rule 13 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < AR_DIV).
    Conflict between rule 13 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < AR_DIV).
    Conflict between rule 13 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 13 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 13 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 13 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 13 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 13 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 13 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 13 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 13 and token LOG_COMPARE resolved as shift (AR_DIV < LOG_COMPARE).


State 76

   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   14     | expr AR_MOD expr .  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 52

    $default  reduce using rule 14 (expr)

    Conflict between rule 14 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < AR_MOD).
    Conflict between rule 14 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < AR_MOD).
    Conflict between rule 14 and token REL_EQUAL resolved as reduce (REL_EQUAL < AR_MOD).
    Conflict between rule 14 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < AR_MOD).
    Conflict between rule 14 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < AR_MOD).
    Conflict between rule 14 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < AR_MOD).
    Conflict between rule 14 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 14 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 14 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 14 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 14 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 14 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 14 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 14 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 14 and token LOG_COMPARE resolved as shift (AR_MOD < LOG_COMPARE).


State 77

   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   16     | expr BITWISE_XOR expr .  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 52

    $default  reduce using rule 16 (expr)

    Conflict between rule 16 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < BITWISE_XOR).
    Conflict between rule 16 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < BITWISE_XOR).
    Conflict between rule 16 and token REL_EQUAL resolved as reduce (REL_EQUAL < BITWISE_XOR).
    Conflict between rule 16 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < BITWISE_XOR).
    Conflict between rule 16 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < BITWISE_XOR).
    Conflict between rule 16 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < BITWISE_XOR).
    Conflict between rule 16 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 16 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 16 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 16 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 16 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 16 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 16 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 16 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 16 and token LOG_COMPARE resolved as shift (BITWISE_XOR < LOG_COMPARE).


State 78

   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   19     | expr BITWISE_AND BITWISE_AND . expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13

    $default  reduce using rule 31 (expr)

    expr  go to state 88


State 79

   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   18     | expr BITWISE_AND expr .  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 52

    $default  reduce using rule 18 (expr)

    Conflict between rule 18 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < BITWISE_AND).
    Conflict between rule 18 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < BITWISE_AND).
    Conflict between rule 18 and token REL_EQUAL resolved as reduce (REL_EQUAL < BITWISE_AND).
    Conflict between rule 18 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < BITWISE_AND).
    Conflict between rule 18 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < BITWISE_AND).
    Conflict between rule 18 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < BITWISE_AND).
    Conflict between rule 18 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 18 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 18 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 18 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 18 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 18 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 18 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 18 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 18 and token LOG_COMPARE resolved as shift (BITWISE_AND < LOG_COMPARE).


State 80

   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   20     | expr BITWISE_OR BITWISE_AND . expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13

    $default  reduce using rule 31 (expr)

    expr  go to state 89


State 81

   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   17     | expr BITWISE_OR expr .  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 52

    $default  reduce using rule 17 (expr)

    Conflict between rule 17 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < BITWISE_OR).
    Conflict between rule 17 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < BITWISE_OR).
    Conflict between rule 17 and token REL_EQUAL resolved as reduce (REL_EQUAL < BITWISE_OR).
    Conflict between rule 17 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < BITWISE_OR).
    Conflict between rule 17 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < BITWISE_OR).
    Conflict between rule 17 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < BITWISE_OR).
    Conflict between rule 17 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 17 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 17 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 17 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 17 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 17 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 17 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 17 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 17 and token LOG_COMPARE resolved as shift (BITWISE_OR < LOG_COMPARE).


State 82

   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   21     | expr LOG_COMPARE LOG_COMPARE . expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13

    $default  reduce using rule 31 (expr)

    expr  go to state 90


State 83

   32 datatype: . FLOAT
   33         | . DOUBLE
   34         | . CHAR
   35         | . UNSIGNED CHAR
   36         | . INT
   37         | . UNSIGNED INT
   38         | . SHORT INT
   39         | . SHORT UNSIGNED INT
   40         | . LONG INT
   41         | . LONG UNSIGNED INT
   42         | . "void"
   58 arg: . datatype IDENTIFIER
   59    | . arg ','
   60 func_dec: datatype IDENTIFIER L_PAREN . arg R_PAREN

    CHAR      shift, and go to state 1
    INT       shift, and go to state 2
    FLOAT     shift, and go to state 3
    DOUBLE    shift, and go to state 4
    SHORT     shift, and go to state 5
    UNSIGNED  shift, and go to state 6
    LONG      shift, and go to state 7
    "void"    shift, and go to state 14

    datatype  go to state 91
    arg       go to state 92


State 84

   46 var_def: var_dec '=' NUM_INTEGER .

    $default  reduce using rule 46 (var_def)


State 85

   45 var_def: var_dec '=' NUM_FLOAT .

    $default  reduce using rule 45 (var_def)


State 86

   55 if_elses: IF L_PAREN expr R_PAREN . L_FLOWER_BRKT block R_FLOWER_BRKT else_if ELSE L_FLOWER_BRKT block R_FLOWER_BRKT
   56         | IF L_PAREN expr R_PAREN . L_FLOWER_BRKT block R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 93


State 87

   57 while: WHILE L_PAREN expr R_PAREN . L_FLOWER_BRKT block R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 94


State 88

   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   19     | expr BITWISE_AND BITWISE_AND expr .  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 52

    $default  reduce using rule 19 (expr)

    Conflict between rule 19 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < BITWISE_AND).
    Conflict between rule 19 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < BITWISE_AND).
    Conflict between rule 19 and token REL_EQUAL resolved as reduce (REL_EQUAL < BITWISE_AND).
    Conflict between rule 19 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < BITWISE_AND).
    Conflict between rule 19 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < BITWISE_AND).
    Conflict between rule 19 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < BITWISE_AND).
    Conflict between rule 19 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 19 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 19 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 19 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 19 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 19 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 19 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 19 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 19 and token LOG_COMPARE resolved as shift (BITWISE_AND < LOG_COMPARE).


State 89

   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   20     | expr BITWISE_OR BITWISE_AND expr .  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR]
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr

    LOG_COMPARE  shift, and go to state 52

    $default  reduce using rule 20 (expr)

    Conflict between rule 20 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < BITWISE_AND).
    Conflict between rule 20 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < BITWISE_AND).
    Conflict between rule 20 and token REL_EQUAL resolved as reduce (REL_EQUAL < BITWISE_AND).
    Conflict between rule 20 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < BITWISE_AND).
    Conflict between rule 20 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < BITWISE_AND).
    Conflict between rule 20 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < BITWISE_AND).
    Conflict between rule 20 and token AR_PLUS resolved as reduce (%left AR_PLUS).
    Conflict between rule 20 and token AR_MINUS resolved as reduce (%left AR_MINUS).
    Conflict between rule 20 and token AR_MUL resolved as reduce (%left AR_MUL).
    Conflict between rule 20 and token AR_DIV resolved as reduce (%left AR_DIV).
    Conflict between rule 20 and token AR_MOD resolved as reduce (%left AR_MOD).
    Conflict between rule 20 and token BITWISE_XOR resolved as reduce (%left BITWISE_XOR).
    Conflict between rule 20 and token BITWISE_AND resolved as reduce (%left BITWISE_AND).
    Conflict between rule 20 and token BITWISE_OR resolved as reduce (%left BITWISE_OR).
    Conflict between rule 20 and token LOG_COMPARE resolved as shift (BITWISE_AND < LOG_COMPARE).


State 90

   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   21     | expr LOG_COMPARE LOG_COMPARE expr .  [$end, R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr

    $default  reduce using rule 21 (expr)

    Conflict between rule 21 and token REL_LESSEQUAL resolved as reduce (REL_LESSEQUAL < LOG_COMPARE).
    Conflict between rule 21 and token REL_GREATEQUAL resolved as reduce (REL_GREATEQUAL < LOG_COMPARE).
    Conflict between rule 21 and token REL_EQUAL resolved as reduce (REL_EQUAL < LOG_COMPARE).
    Conflict between rule 21 and token REL_NOTEQUAL resolved as reduce (REL_NOTEQUAL < LOG_COMPARE).
    Conflict between rule 21 and token REL_LESSTHAN resolved as reduce (REL_LESSTHAN < LOG_COMPARE).
    Conflict between rule 21 and token REL_GREATERTHAN resolved as reduce (REL_GREATERTHAN < LOG_COMPARE).
    Conflict between rule 21 and token AR_PLUS resolved as reduce (AR_PLUS < LOG_COMPARE).
    Conflict between rule 21 and token AR_MINUS resolved as reduce (AR_MINUS < LOG_COMPARE).
    Conflict between rule 21 and token AR_MUL resolved as reduce (AR_MUL < LOG_COMPARE).
    Conflict between rule 21 and token AR_DIV resolved as reduce (AR_DIV < LOG_COMPARE).
    Conflict between rule 21 and token AR_MOD resolved as reduce (AR_MOD < LOG_COMPARE).
    Conflict between rule 21 and token BITWISE_XOR resolved as reduce (BITWISE_XOR < LOG_COMPARE).
    Conflict between rule 21 and token BITWISE_AND resolved as reduce (BITWISE_AND < LOG_COMPARE).
    Conflict between rule 21 and token BITWISE_OR resolved as reduce (BITWISE_OR < LOG_COMPARE).
    Conflict between rule 21 and token LOG_COMPARE resolved as reduce (%left LOG_COMPARE).


State 91

   58 arg: datatype . IDENTIFIER

    IDENTIFIER  shift, and go to state 95


State 92

   59 arg: arg . ','
   60 func_dec: datatype IDENTIFIER L_PAREN arg . R_PAREN

    R_PAREN  shift, and go to state 96
    ','      shift, and go to state 97


State 93

   50 block: . L_FLOWER_BRKT R_FLOWER_BRKT
   51      | . L_FLOWER_BRKT block R_FLOWER_BRKT
   52      | . L_FLOWER_BRKT "blah!" R_FLOWER_BRKT
   55 if_elses: IF L_PAREN expr R_PAREN L_FLOWER_BRKT . block R_FLOWER_BRKT else_if ELSE L_FLOWER_BRKT block R_FLOWER_BRKT
   56         | IF L_PAREN expr R_PAREN L_FLOWER_BRKT . block R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 10

    block  go to state 98


State 94

   50 block: . L_FLOWER_BRKT R_FLOWER_BRKT
   51      | . L_FLOWER_BRKT block R_FLOWER_BRKT
   52      | . L_FLOWER_BRKT "blah!" R_FLOWER_BRKT
   57 while: WHILE L_PAREN expr R_PAREN L_FLOWER_BRKT . block R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 10

    block  go to state 99


State 95

   58 arg: datatype IDENTIFIER .

    $default  reduce using rule 58 (arg)


State 96

   60 func_dec: datatype IDENTIFIER L_PAREN arg R_PAREN .

    $default  reduce using rule 60 (func_dec)


State 97

   59 arg: arg ',' .

    $default  reduce using rule 59 (arg)


State 98

   55 if_elses: IF L_PAREN expr R_PAREN L_FLOWER_BRKT block . R_FLOWER_BRKT else_if ELSE L_FLOWER_BRKT block R_FLOWER_BRKT
   56         | IF L_PAREN expr R_PAREN L_FLOWER_BRKT block . R_FLOWER_BRKT

    R_FLOWER_BRKT  shift, and go to state 100


State 99

   57 while: WHILE L_PAREN expr R_PAREN L_FLOWER_BRKT block . R_FLOWER_BRKT

    R_FLOWER_BRKT  shift, and go to state 101


State 100

   53 else_if: . ELSE L_FLOWER_BRKT block R_FLOWER_BRKT IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT
   54        | . else_if
   55 if_elses: IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT . else_if ELSE L_FLOWER_BRKT block R_FLOWER_BRKT
   56         | IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT .  [$end]

    ELSE  shift, and go to state 102

    $default  reduce using rule 56 (if_elses)

    else_if  go to state 103


State 101

   57 while: WHILE L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT .

    $default  reduce using rule 57 (while)


State 102

   53 else_if: ELSE . L_FLOWER_BRKT block R_FLOWER_BRKT IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 104


State 103

   54 else_if: else_if .  [ELSE]
   55 if_elses: IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT else_if . ELSE L_FLOWER_BRKT block R_FLOWER_BRKT

    ELSE  shift, and go to state 105

    ELSE  [reduce using rule 54 (else_if)]


State 104

   50 block: . L_FLOWER_BRKT R_FLOWER_BRKT
   51      | . L_FLOWER_BRKT block R_FLOWER_BRKT
   52      | . L_FLOWER_BRKT "blah!" R_FLOWER_BRKT
   53 else_if: ELSE L_FLOWER_BRKT . block R_FLOWER_BRKT IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 10

    block  go to state 106


State 105

   55 if_elses: IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT else_if ELSE . L_FLOWER_BRKT block R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 107


State 106

   53 else_if: ELSE L_FLOWER_BRKT block . R_FLOWER_BRKT IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

    R_FLOWER_BRKT  shift, and go to state 108


State 107

   50 block: . L_FLOWER_BRKT R_FLOWER_BRKT
   51      | . L_FLOWER_BRKT block R_FLOWER_BRKT
   52      | . L_FLOWER_BRKT "blah!" R_FLOWER_BRKT
   55 if_elses: IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT else_if ELSE L_FLOWER_BRKT . block R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 10

    block  go to state 109


State 108

   53 else_if: ELSE L_FLOWER_BRKT block R_FLOWER_BRKT . IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

    IF  shift, and go to state 110


State 109

   55 if_elses: IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT else_if ELSE L_FLOWER_BRKT block . R_FLOWER_BRKT

    R_FLOWER_BRKT  shift, and go to state 111


State 110

   53 else_if: ELSE L_FLOWER_BRKT block R_FLOWER_BRKT IF . L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

    L_PAREN  shift, and go to state 112


State 111

   55 if_elses: IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT else_if ELSE L_FLOWER_BRKT block R_FLOWER_BRKT .

    $default  reduce using rule 55 (if_elses)


State 112

   10 expr: . expr AR_PLUS expr
   11     | . expr AR_MINUS expr
   12     | . expr AR_MUL expr
   13     | . expr AR_DIV expr
   14     | . expr AR_MOD expr
   15     | . expr AR_PLUS AR_PLUS
   16     | . expr BITWISE_XOR expr
   17     | . expr BITWISE_OR expr
   18     | . expr BITWISE_AND expr
   19     | . expr BITWISE_AND BITWISE_AND expr
   20     | . expr BITWISE_OR BITWISE_AND expr
   21     | . expr LOG_COMPARE LOG_COMPARE expr
   22     | . expr REL_LESSTHAN expr
   23     | . expr REL_LESSEQUAL expr
   24     | . expr REL_EQUAL expr
   25     | . expr REL_GREATEQUAL expr
   26     | . expr REL_GREATERTHAN expr
   27     | . expr REL_NOTEQUAL expr
   28     | . NUM_INTEGER
   29     | . NUM_FLOAT
   30     | . IDENTIFIER
   31     | . %empty  [R_PAREN, REL_LESSEQUAL, REL_GREATEQUAL, REL_EQUAL, REL_NOTEQUAL, REL_LESSTHAN, REL_GREATERTHAN, AR_PLUS, AR_MINUS, AR_MUL, AR_DIV, AR_MOD, BITWISE_XOR, BITWISE_AND, BITWISE_OR, LOG_COMPARE]
   53 else_if: ELSE L_FLOWER_BRKT block R_FLOWER_BRKT IF L_PAREN . expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

    IDENTIFIER   shift, and go to state 58
    NUM_INTEGER  shift, and go to state 12
    NUM_FLOAT    shift, and go to state 13

    $default  reduce using rule 31 (expr)

    expr  go to state 113


State 113

   10 expr: expr . AR_PLUS expr
   11     | expr . AR_MINUS expr
   12     | expr . AR_MUL expr
   13     | expr . AR_DIV expr
   14     | expr . AR_MOD expr
   15     | expr . AR_PLUS AR_PLUS
   16     | expr . BITWISE_XOR expr
   17     | expr . BITWISE_OR expr
   18     | expr . BITWISE_AND expr
   19     | expr . BITWISE_AND BITWISE_AND expr
   20     | expr . BITWISE_OR BITWISE_AND expr
   21     | expr . LOG_COMPARE LOG_COMPARE expr
   22     | expr . REL_LESSTHAN expr
   23     | expr . REL_LESSEQUAL expr
   24     | expr . REL_EQUAL expr
   25     | expr . REL_GREATEQUAL expr
   26     | expr . REL_GREATERTHAN expr
   27     | expr . REL_NOTEQUAL expr
   53 else_if: ELSE L_FLOWER_BRKT block R_FLOWER_BRKT IF L_PAREN expr . R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT

    R_PAREN          shift, and go to state 114
    REL_LESSEQUAL    shift, and go to state 38
    REL_GREATEQUAL   shift, and go to state 39
    REL_EQUAL        shift, and go to state 40
    REL_NOTEQUAL     shift, and go to state 41
    REL_LESSTHAN     shift, and go to state 42
    REL_GREATERTHAN  shift, and go to state 43
    AR_PLUS          shift, and go to state 44
    AR_MINUS         shift, and go to state 45
    AR_MUL           shift, and go to state 46
    AR_DIV           shift, and go to state 47
    AR_MOD           shift, and go to state 48
    BITWISE_XOR      shift, and go to state 49
    BITWISE_AND      shift, and go to state 50
    BITWISE_OR       shift, and go to state 51
    LOG_COMPARE      shift, and go to state 52


State 114

   53 else_if: ELSE L_FLOWER_BRKT block R_FLOWER_BRKT IF L_PAREN expr R_PAREN . L_FLOWER_BRKT block R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 115


State 115

   50 block: . L_FLOWER_BRKT R_FLOWER_BRKT
   51      | . L_FLOWER_BRKT block R_FLOWER_BRKT
   52      | . L_FLOWER_BRKT "blah!" R_FLOWER_BRKT
   53 else_if: ELSE L_FLOWER_BRKT block R_FLOWER_BRKT IF L_PAREN expr R_PAREN L_FLOWER_BRKT . block R_FLOWER_BRKT

    L_FLOWER_BRKT  shift, and go to state 10

    block  go to state 116


State 116

   53 else_if: ELSE L_FLOWER_BRKT block R_FLOWER_BRKT IF L_PAREN expr R_PAREN L_FLOWER_BRKT block . R_FLOWER_BRKT

    R_FLOWER_BRKT  shift, and go to state 117


State 117

   53 else_if: ELSE L_FLOWER_BRKT block R_FLOWER_BRKT IF L_PAREN expr R_PAREN L_FLOWER_BRKT block R_FLOWER_BRKT .

    $default  reduce using rule 53 (else_if)
